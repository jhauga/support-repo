<!DOCTYPE html>
<html>
<head> <title>curl - TODO</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<link rel="stylesheet" type="text/css" href="/curl.css">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="icon" href="/logo/curl-symbol.svg" type="image/svg+xml">
<link rel="alternate" type="application/rss+xml" title="cURL Releases" href="https://github.com/curl/curl/releases.atom">
<style>
input[type=checkbox] {
    display: none;
}
ul.task-list {
    list-style-type: none;
}
</style>
</head>
<body>
<div class="main">
<div class="menu">
<a href="/docs/" class="menuitem" title="Documentation Overview">Docs Overview</a>
<div class="dropdown">
  <a class="dropbtn" href="/docs/projdocs.html">Project</a>
  <div class="dropdown-content">
    <a href="/docs/bugbounty.html">Bug Bounty</a>
    <a href="/docs/bugs.html">Bug Report</a>
    <a href="/docs/code-of-conduct.html">Code of conduct</a>
    <a href="/docs/libs.html">Dependencies</a>
    <a href="/donation.html">Donate</a>
    <a href="/docs/faq.html">FAQ</a>
    <a href="/docs/features.html">Features</a>
    <a href="/docs/governance.html">Governance</a>
    <a href="/docs/history.html">History</a>
    <a href="/docs/install.html">Install</a>
    <a href="/docs/knownbugs.html">Known Bugs</a>
    <a href="/docs/knownrisks.html">Known Risks</a>
    <a href="/logo/">Logo</a>
    <a href="/docs/todo.html">TODO</a>
    <a href="/about.html">website Info</a>
  </div>
</div>
<div class="dropdown">
  <a class="dropbtn" href="/docs/protdocs.html">Protocols</a>
  <div class="dropdown-content">
    <a href="/docs/caextract.html">CA Extract</a>
    <a href="/docs/http-cookies.html">HTTP cookies</a>
    <a href="/docs/http3.html">HTTP/3</a>
    <a href="/docs/mqtt.html">MQTT</a>
    <a href="/docs/sslcerts.html">SSL certs</a>
    <a href="/docs/ssl-compared.html">SSL libs compared</a>
    <a href="/docs/url-syntax.html">URL syntax</a>
    <a href="/docs/websocket.html">WebSocket</a>
  </div>
</div>
<div class="dropdown">
  <a class="dropbtn" href="/docs/reldocs.html">Releases</a>
  <div class="dropdown-content">
    <a href="/ch/">Changelog</a>
    <a href="/docs/security.html">curl CVEs</a>
    <a href="/docs/releases.html">Release Table</a>
    <a href="/docs/versions.html">Version Numbering</a>
    <a href="/docs/vulnerabilities.html">Vulnerabilities</a>
  </div>
</div>
<div class="dropdown">
  <a class="dropbtn" href="/docs/tooldocs.html">Tool</a>
  <div class="dropdown-content">
    <a href="/docs/comparison-table.html">Comparison Table</a>
    <a href="/docs/manpage.html">curl man page</a>
    <a href="/docs/httpscripting.html">HTTP Scripting</a>
    <a href="/docs/mk-ca-bundle.html">mk-ca-bundle</a>
    <a href="/docs/tutorial.html">Tutorial</a>
    <a href="optionswhen.html">When options were added</a>
  </div>
</div>
<div class="dropdown">
  <a class="dropbtn" href="/docs/whodocs.html">Who and Why</a>
  <div class="dropdown-content">
    <a href="/docs/companies.html">Companies</a>
    <a href="/docs/copyright.html">Copyright</a>
    <a href="/sponsors.html">Sponsors</a>
    <a href="/docs/thanks.html">Thanks</a>
    <a href="/docs/thename.html">The name</a>
  </div>
</div>
</div>
<div class="contents">
<div class="where"><a href="/">curl</a> / <a href="/docs/">Docs</a> / <a href="/docs/projdocs.html">Project</a> / <b>Nice to have features</b></div>
<div class="relatedbox">
<b>Related:</b>
<br><a href="/dev/deprecate.html">Deprecate</a>
<br><a href="knownbugs.html">Known Bugs</a>
<br><a href="bugs.html">How To Report Bugs</a>
</div>
<h2><a href="#libcurl">libcurl</a></h2>
<p>
<a href="#TFO_support_on_Windows">TFO support on Windows</a><br>
<a href="#Consult_APPDATA_also_for_netr">Consult %APPDATA% also for .netrc</a><br>
<a href="#struct_lifreq">struct lifreq</a><br>
<a href="#alt_svc_sharing">alt-svc sharing</a><br>
<a href="#get_rid_of_PATH_MAX">get rid of PATH_MAX</a><br>
<a href="#thread_safe_sharing">thread-safe sharing</a><br>
<a href="#auto_detect_proxy">auto-detect proxy</a><br>
<a href="#updated_DNS_server_while_running">updated DNS server while running</a><br>
<a href="#c_ares_and_CURLOPT_OPENSOCKETFUN">c-ares and CURLOPT_OPENSOCKETFUNCTION</a><br>
<a href="#Monitor_connections_in_the_conne">Monitor connections in the connection pool</a><br>
<a href="#Try_to_URL_encode_given_URL">Try to URL encode given URL</a><br>
<a href="#Add_support_for_IRIs">Add support for IRIs</a><br>
<a href="#try_next_proxy_if_one_does_not_w">try next proxy if one does not work</a><br>
<a href="#provide_timing_info_for_each_red">provide timing info for each redirect</a><br>
<a href="#SRV_and_URI_DNS_records">SRV and URI DNS records</a><br>
<a href="#CURLINFO_PAUSE_STATE">CURLINFO_PAUSE_STATE</a><br>
<a href="#Expose_tried_IP_addresses_that_f">Expose tried IP addresses that failed</a><br>
<a href="#config_file_parsing">config file parsing</a><br>
<a href="#erase_secrets_from_heap_stack_af">erase secrets from heap/stack after use</a><br>
<a href="#add_asynch_getaddrinfo_support">add asynch getaddrinfo support</a><br>
<a href="#make_DoH_inherit_more_transfer_p">make DoH inherit more transfer properties</a><br>
</p>
<h2><a href="#libcurl--multi-interface">libcurl - multi interface</a></h2>
<p>
<a href="#More_non_blocking">More non-blocking</a><br>
<a href="#Better_support_for_same_name_res">Better support for same name resolves</a><br>
<a href="#Non_blocking_curl_multi_remove_h">Non-blocking curl_multi_remove_handle()</a><br>
<a href="#Split_connect_and_authentication">Split connect and authentication process</a><br>
<a href="#Edge_triggered_sockets_should_wo">Edge-triggered sockets should work</a><br>
<a href="#multi_upkeep">multi upkeep</a><br>
<a href="#Virtual_external_sockets">Virtual external sockets</a><br>
<a href="#dynamically_decide_to_use_socket">dynamically decide to use socketpair</a><br>
</p>
<h2><a href="#Documentation">Documentation</a></h2>
<p>
<a href="#Improve_documentation_about_fork">Improve documentation about fork safety</a><br>
</p>
<h2><a href="#FTP">FTP</a></h2>
<p>
<a href="#HOST">HOST</a><br>
<a href="#A_fixed_directory_listing_format">A fixed directory listing format</a><br>
<a href="#GSSAPI_via_Windows_SSPI">GSSAPI via Windows SSPI</a><br>
<a href="#STAT_for_LIST_without_data_conne">STAT for LIST without data connection</a><br>
<a href="#Passive_transfer_could_try_other">Passive transfer could try other IP addresses</a><br>
</p>
<h2><a href="#HTTP">HTTP</a></h2>
<p>
<a href="#Provide_the_error_body_from_a_CO">Provide the error body from a CONNECT response</a><br>
<a href="#Obey_Retry_After_in_redirects">Obey Retry-After in redirects</a><br>
<a href="#Rearrange_request_header_order">Rearrange request header order</a><br>
<a href="#Allow_SAN_names_in_HTTP_2_server">Allow SAN names in HTTP/2 server push</a><br>
<a href="#auth_in_URLs">auth= in URLs</a><br>
<a href="#alt_svc_should_fallback_if_alt_s">alt-svc should fallback if alt-svc does not work</a><br>
<a href="#Require_HTTP_version_X_or_higher">Require HTTP version X or higher</a><br>
</p>
<h2><a href="#TELNET">TELNET</a></h2>
<p>
<a href="#ditch_stdin">ditch stdin</a><br>
<a href="#ditch_telnet_specific_select">ditch telnet-specific select</a><br>
<a href="#feature_negotiation_debug_data">feature negotiation debug data</a><br>
<a href="#exit_immediately_upon_connection">exit immediately upon connection if stdin is /dev/null</a><br>
</p>
<h2><a href="#SMTP">SMTP</a></h2>
<p>
<a href="#Passing_NOTIFY_option_to_CURLOPT">Passing NOTIFY option to CURLOPT_MAIL_RCPT</a><br>
<a href="#Enhanced_capability_support">Enhanced capability support</a><br>
<a href="#Add_CURLOPT_MAIL_CLIENT_option">Add CURLOPT_MAIL_CLIENT option</a><br>
</p>
<h2><a href="#POP3">POP3</a></h2>
<p>
<a href="#Enhanced_capability_support">Enhanced capability support</a><br>
</p>
<h2><a href="#IMAP">IMAP</a></h2>
<p>
<a href="#Enhanced_capability_support">Enhanced capability support</a><br>
</p>
<h2><a href="#LDAP">LDAP</a></h2>
<p>
<a href="#SASL_based_authentication_mechan">SASL based authentication mechanisms</a><br>
<a href="#CURLOPT_SSL_CTX_FUNCTION_for_LDA">CURLOPT_SSL_CTX_FUNCTION for LDAPS</a><br>
<a href="#Paged_searches_on_LDAP_server">Paged searches on LDAP server</a><br>
<a href="#Certificate_Based_Authentication">Certificate-Based Authentication</a><br>
</p>
<h2><a href="#SMB">SMB</a></h2>
<p>
<a href="#File_listing_support">File listing support</a><br>
<a href="#Honor_file_timestamps">Honor file timestamps</a><br>
<a href="#Use_NTLMv2">Use NTLMv2</a><br>
<a href="#Create_remote_directories">Create remote directories</a><br>
</p>
<h2><a href="#FILE">FILE</a></h2>
<p>
<a href="#Directory_listing_on_non_POSIX">Directory listing on non-POSIX</a><br>
</p>
<h2><a href="#TLS">TLS</a></h2>
<p>
<a href="#TLS_PSK_with_OpenSSL">TLS-PSK with OpenSSL</a><br>
<a href="#TLS_channel_binding">TLS channel binding</a><br>
<a href="#Defeat_TLS_fingerprinting">Defeat TLS fingerprinting</a><br>
<a href="#Consider_OCSP_stapling_by_defaul">Consider OCSP stapling by default</a><br>
<a href="#Provide_callback_for_cert_verifi">Provide callback for cert verification</a><br>
<a href="#Less_memory_massaging_with_Schan">Less memory massaging with Schannel</a><br>
<a href="#Support_DANE">Support DANE</a><br>
<a href="#TLS_record_padding">TLS record padding</a><br>
<a href="#Support_Authority_Information_Ac">Support Authority Information Access certificate extension (AIA)</a><br>
<a href="#Some_TLS_options_are_not_offered">Some TLS options are not offered for HTTPS proxies</a><br>
<a href="#Make_sure_we_forbid_TLS_1_3_post">Make sure we forbid TLS 1.3 post-handshake authentication</a><br>
<a href="#Support_the_clienthello_extensio">Support the clienthello extension</a><br>
<a href="#Share_the_CA_cache">Share the CA cache</a><br>
<a href="#Add_missing_features_to_TLS_back">Add missing features to TLS backends</a><br>
</p>
<h2><a href="#Proxy">Proxy</a></h2>
<p>
<a href="#Retry_SOCKS_handshake_on_address">Retry SOCKS handshake on address type not supported</a><br>
</p>
<h2><a href="#Schannel">Schannel</a></h2>
<p>
<a href="#Extend_support_for_client_certif">Extend support for client certificate authentication</a><br>
<a href="#Extend_support_for_the_ciphers">Extend support for the --ciphers option</a><br>
<a href="#Add_option_to_allow_abrupt_serve">Add option to allow abrupt server closure</a><br>
</p>
<h2><a href="#SASL">SASL</a></h2>
<p>
<a href="#Other_authentication_mechanisms">Other authentication mechanisms</a><br>
<a href="#Add_QOP_support_to_GSSAPI_authen">Add QOP support to GSSAPI authentication</a><br>
</p>
<h2><a href="#SSH-protocols">SSH protocols</a></h2>
<p>
<a href="#Multiplexing">Multiplexing</a><br>
<a href="#Handle_growing_SFTP_files">Handle growing SFTP files</a><br>
<a href="#Read_keys_from_ssh_id_ecdsa">Read keys from ~/.ssh/id_ecdsa, id_ed25519</a><br>
<a href="#Support_CURLOPT_PREQUOTE">Support CURLOPT_PREQUOTE</a><br>
<a href="#SSH_over_HTTPS_proxy_with_more_b">SSH over HTTPS proxy with more backends</a><br>
<a href="#SFTP_with_SCP">SFTP with SCP://</a><br>
</p>
<h2><a href="#Command-line-tool">Command line tool</a></h2>
<p>
<a href="#sync">sync</a><br>
<a href="#glob_posts">glob posts</a><br>
<a href="#proxycommand">--proxycommand</a><br>
<a href="#UTF_8_filenames_in_Content_Dispo">UTF-8 filenames in Content-Disposition</a><br>
<a href="#Option_to_make_Z_merge_lined_ba">Option to make -Z merge lined based outputs on stdout</a><br>
<a href="#specify_which_response_codes_tha">specify which response codes that make -f/--fail return error</a><br>
<a href="#Choose_the_name_of_file_in_brace">Choose the name of file in braces for complex URLs</a><br>
<a href="#improve_how_curl_works_in_a_Wind">improve how curl works in a Windows console window</a><br>
<a href="#Windows_set_attribute_archive">Windows: set attribute 'archive' for completed downloads</a><br>
<a href="#keep_running_read_instructions">keep running, read instructions from pipe/socket</a><br>
<a href="#Acknowledge_Ratelimit_headers">Acknowledge Ratelimit headers</a><br>
<a href="#dry_run">--dry-run</a><br>
<a href="#retry_should_resume">--retry should resume</a><br>
<a href="#consider_filename_from_the_redir">consider filename from the redirected URL with -O ?</a><br>
<a href="#retry_on_network_is_unreachable">retry on network is unreachable</a><br>
<a href="#hostname_sections_in_config_file">hostname sections in config files</a><br>
<a href="#retry_on_the_redirected_to_URL">retry on the redirected-to URL</a><br>
<a href="#Set_the_modification_date_on_an">Set the modification date on an uploaded file</a><br>
<a href="#Use_multiple_parallel_transfers">Use multiple parallel transfers for a single download</a><br>
<a href="#Prevent_terminal_injection_when">Prevent terminal injection when writing to terminal</a><br>
<a href="#Custom_progress_meter_update_int">Custom progress meter update interval</a><br>
<a href="#J_and_O_with_encoded_filenam">-J and -O with %-encoded filenames</a><br>
<a href="#J_with_C">-J with -C -</a><br>
<a href="#retry_and_transfer_timeouts">--retry and transfer timeouts</a><br>
</p>
<h2><a href="#Build">Build</a></h2>
<p>
<a href="#Enable_PIE_and_RELRO_by_default">Enable PIE and RELRO by default</a><br>
<a href="#Do_not_use_GNU_libtool_on_OpenBS">Do not use GNU libtool on OpenBSD</a><br>
<a href="#Package_curl_for_Windows_in_a_si">Package curl for Windows in a signed installer</a><br>
<a href="#make_configure_use_cache_file">make configure use --cache-file more and better</a><br>
</p>
<h2><a href="#Test-suite">Test suite</a></h2>
<p>
<a href="#SSL_tunnel">SSL tunnel</a><br>
<a href="#more_protocols_supported">more protocols supported</a><br>
<a href="#more_platforms_supported">more platforms supported</a><br>
<a href="#write_an_SMB_test_server_to_repl">write an SMB test server to replace impacket</a><br>
<a href="#Use_the_RFC_6265_test_suite">Use the RFC 6265 test suite</a><br>
<a href="#Run_web_platform_tests_URL_tests">Run web-platform-tests URL tests</a><br>
</p>
<h2><a href="#MQTT">MQTT</a></h2>
<p>
<a href="#Support_rate_limiting">Support rate-limiting</a><br>
<a href="#Support_MQTTS">Support MQTTS</a><br>
<a href="#Handle_network_blocks">Handle network blocks</a><br>
<a href="#large_payloads">large payloads</a><br>
</p>
<h2><a href="#TFTP">TFTP</a></h2>
<p>
<a href="#TFTP_does_not_convert_LF_to_CRLF">TFTP does not convert LF to CRLF for mode=netascii</a><br>
</p>
<h2><a href="#Gopher">Gopher</a></h2>
<p>
<a href="#Handle_network_blocks">Handle network blocks</a><br>
</p>
<!-- CONTENT WITH MODIFIED IDS -->
<p><!--
Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.</p>
<p>SPDX-License-Identifier: curl
--></p>
<p>Things to do in project curl. Please tell us what you think, contribute and
send us patches that improve things.</p>
<p>Be aware that these are things that we could do, or have once been considered
things we could do. If you want to work on any of these areas, please
consider bringing it up for discussions first on the mailing list so that we
all agree it is still a good idea for the project.</p>
<p>All bugs documented in the KNOWN_BUGS document are subject for fixing.</p>
<h2 id="libcurl">libcurl</h2>
<h3 id="TFO_support_on_Windows">TFO support on Windows</h3>
<p>libcurl supports the `CURLOPT_TCP_FASTOPEN` option since 7.49.0 for Linux and
macOS. Windows supports TCP Fast Open starting with Windows 10, version 1607
and we should add support for it.</p>
<p>TCP Fast Open is supported on several platforms but not on Windows. Work on
this was once started but never finished.</p>
<p>See <a href="https://github.com/curl/curl/pull/3378">curl/curl#3378</a></p>
<h3 id="Consult_APPDATA_also_for_netr">Consult %APPDATA% also for .netrc</h3>
<p>`%APPDATA%\.netrc` is not considered when running on Windows. should not it?</p>
<p>See <a href="https://github.com/curl/curl/issues/4016">curl/curl#4016</a></p>
<h3 id="struct_lifreq">struct lifreq</h3>
<p>Use `struct lifreq` and `SIOCGLIFADDR` instead of `struct ifreq` and
`SIOCGIFADDR` on newer Solaris versions as they claim the latter is obsolete.
To support IPv6 interface addresses for network interfaces properly.</p>
<h3 id="alt_svc_sharing">alt-svc sharing</h3>
<p>The share interface could benefit from allowing the alt-svc cache to be
possible to share between easy handles.</p>
<p>See <a href="https://github.com/curl/curl/issues/4476">curl/curl#4476</a></p>
<p>The share interface offers `CURL_LOCK_DATA_CONNECT` to have multiple easy
handle share a connection cache, but due to how connections are used they are
still not thread-safe when used shared. See:</p>
<p>- <a href="https://github.com/curl/curl/issues/4915">curl/curl#4915</a>
- [lib1541.c](https://github.com/curl/curl/blob/master/tests/libtest/lib1541.c)</p>
<p>The share interface offers `CURL_LOCK_DATA_HSTS` to have multiple easy handle
share an HSTS cache, but this is not thread-safe.</p>
<h3 id="get_rid_of_PATH_MAX">get rid of PATH_MAX</h3>
<p>Having code use and rely on `PATH_MAX` is not nice.</p>
<p>See
https://insanecoding.blogspot.com/2007/11/pathmax-simply-isnt.html</p>
<p>Currently the libssh2 SSH based code uses it, but to remove `PATH_MAX` from
there we need libssh2 to properly tell us when we pass in a too small buffer
and its current API (as of libssh2 1.2.7) does not.</p>
<h3 id="thread_safe_sharing">thread-safe sharing</h3>
<p>Using the share interface users can share some data between easy handles but
several of the sharing options are documented as not safe and supported to
share between multiple concurrent threads. Fixing this would enable more
users to share data in more powerful ways.</p>
<h3 id="auto_detect_proxy">auto-detect proxy</h3>
<p>libcurl could be made to detect the system proxy setup automatically and use
that. On Windows, macOS and Linux desktops for example.</p>
<p>The pull-request to use libproxy for this was deferred due to doubts on the
reliability of the dependency and how to use it.</p>
<p>See <a href="https://github.com/curl/curl/pull/977">curl/curl#977</a></p>
<p>libdetectproxy is a (C++) library for detecting the proxy on Windows.</p>
<p>See [paulharris/libdetectproxy](https://github.com/paulharris/libdetectproxy)</p>
<h3 id="updated_DNS_server_while_running">updated DNS server while running</h3>
<p>If `/etc/resolv.conf` gets updated while a program using libcurl is running, it
is may cause name resolves to fail unless `res_init()` is called. We should
consider calling `res_init()` + retry once unconditionally on all name resolve
failures to mitigate against this. Firefox works like that. Note that Windows
does not have `res_init()` or an alternative.</p>
<p>See <a href="https://github.com/curl/curl/issues/2251">curl/curl#2251</a></p>
<h3 id="c_ares_and_CURLOPT_OPENSOCKETFUN">c-ares and CURLOPT_OPENSOCKETFUNCTION</h3>
<p>curl creates most sockets via the `CURLOPT_OPENSOCKETFUNCTION` callback and
close them with the `CURLOPT_CLOSESOCKETFUNCTION` callback. However, c-ares
does not use those functions and instead opens and closes the sockets itself.
This means that when curl passes the c-ares socket to the
`CURLMOPT_SOCKETFUNCTION` it is not owned by the application like other
sockets.</p>
<p>See <a href="https://github.com/curl/curl/issues/2734">curl/curl#2734</a></p>
<h3 id="Monitor_connections_in_the_conne">Monitor connections in the connection pool</h3>
<p>libcurl's connection cache or pool holds a number of open connections for the
purpose of possible subsequent connection reuse. It may contain a few up to a
significant amount of connections. Currently, libcurl leaves all connections
as they are and first when a connection is iterated over for matching or
reuse purpose it is verified that it is still alive.</p>
<p>Those connections may get closed by the server side for idleness or they may
get an HTTP/2 ping from the peer to verify that they are still alive. By
adding monitoring of the connections while in the pool, libcurl can detect
dead connections (and close them) better and earlier, and it can handle
HTTP/2 pings to keep such ones alive even when not actively doing transfers
on them.</p>
<h3 id="Try_to_URL_encode_given_URL">Try to URL encode given URL</h3>
<p>Given a URL that for example contains spaces, libcurl could have an option
that would try somewhat harder than it does now and convert spaces to `%20`
and perhaps URL encoded byte values over 128 etc (basically do what the
redirect following code already does).</p>
<p>See <a href="https://github.com/curl/curl/issues/514">curl/curl#514</a></p>
<h3 id="Add_support_for_IRIs">Add support for IRIs</h3>
<p>IRIs (RFC 3987) allow localized, non-ASCII, names in the URL. To properly
support this, curl/libcurl would need to translate/encode the given input
from the input string encoding into percent encoded output "over the wire".</p>
<p>To make that work smoothly for curl users even on Windows, curl would
probably need to be able to convert from several input encodings.</p>
<h3 id="try_next_proxy_if_one_does_not_w">try next proxy if one does not work</h3>
<p>Allow an application to specify a list of proxies to try, and failing to
connect to the first go on and try the next instead until the list is
exhausted. Browsers support this feature at least when they specify proxies
using PACs.</p>
<p>See <a href="https://github.com/curl/curl/issues/896">curl/curl#896</a></p>
<h3 id="provide_timing_info_for_each_red">provide timing info for each redirect</h3>
<p>curl and libcurl provide timing information via a set of different
time-stamps (`CURLINFO_*_TIME`). When curl is following redirects, those
returned time value are the accumulated sums. An improvement could be to
offer separate timings for each redirect.</p>
<p>See <a href="https://github.com/curl/curl/issues/6743">curl/curl#6743</a></p>
<h3 id="SRV_and_URI_DNS_records">SRV and URI DNS records</h3>
<p>Offer support for resolving SRV and URI DNS records for libcurl to know which
server to connect to for various protocols (including HTTP).</p>
<h3 id="CURLINFO_PAUSE_STATE">CURLINFO_PAUSE_STATE</h3>
<p>Return information about the transfer's current pause state, in both
directions.</p>
<p>See <a href="https://github.com/curl/curl/issues/2588">curl/curl#2588</a></p>
<h3 id="Expose_tried_IP_addresses_that_f">Expose tried IP addresses that failed</h3>
<p>When libcurl fails to connect to a host, it could offer the application the
addresses that were used in the attempt. Source + dest IP, source + dest port
and protocol (UDP or TCP) for each failure. Possibly as a callback. Perhaps
also provide "reason".</p>
<p>See <a href="https://github.com/curl/curl/issues/2126">curl/curl#2126</a></p>
<h3 id="config_file_parsing">config file parsing</h3>
<p>Consider providing an API, possibly in a separate companion library, for
parsing a config file like curl's -K/--config option to allow applications to
get the same ability to read curl options from files.</p>
<p>See <a href="https://github.com/curl/curl/issues/3698">curl/curl#3698</a></p>
<h3 id="erase_secrets_from_heap_stack_af">erase secrets from heap/stack after use</h3>
<p>Introducing a concept and system to erase secrets from memory after use, it
could help mitigate and lessen the impact of (future) security problems etc.
However: most secrets are passed to libcurl as clear text from the
application and then clearing them within the library adds nothing.</p>
<p>See <a href="https://github.com/curl/curl/issues/7268">curl/curl#7268</a></p>
<h3 id="add_asynch_getaddrinfo_support">add asynch getaddrinfo support</h3>
<p>Use `getaddrinfo_a()` to provide an asynch name resolver backend to libcurl
that does not use threads and does not depend on c-ares. The `getaddrinfo_a`
function is (probably?) glibc specific but that is a widely used libc among
our users.</p>
<p>See <a href="https://github.com/curl/curl/pull/6746">curl/curl#6746</a></p>
<h3 id="make_DoH_inherit_more_transfer_p">make DoH inherit more transfer properties</h3>
<p>Some options are not inherited because they are not relevant for the DoH SSL
connections, or inheriting the option may result in unexpected behavior. For
example the user's debug function callback is not inherited because it would
be unexpected for internal handles (ie DoH handles) to be passed to that
callback.</p>
<p>If an option is not inherited then it is not possible to set it separately
for DoH without a DoH-specific option. For example:
`CURLOPT_DOH_SSL_VERIFYHOST`, `CURLOPT_DOH_SSL_VERIFYPEER` and
`CURLOPT_DOH_SSL_VERIFYSTATUS`.</p>
<p>See <a href="https://github.com/curl/curl/issues/6605">curl/curl#6605</a></p>
<h2 id="libcurl--multi-interface">libcurl - multi interface</h2>
<h3 id="More_non_blocking">More non-blocking</h3>
<p>Make sure we do not ever loop because of non-blocking sockets returning
`EWOULDBLOCK` or similar. Blocking cases include:</p>
<p>- Name resolves on non-Windows unless c-ares or the threaded resolver is used.
- The threaded resolver may block on cleanup:
  - See <a href="https://github.com/curl/curl/issues/4852">curl/curl#4852</a>
- file:// transfers
- TELNET transfers
- GSSAPI authentication for FTP transfers
- The "DONE" operation (post transfer protocol-specific actions) for the
protocols SFTP, SMTP, FTP. Fixing `multi_done()` for this is a worthy task.
- `curl_multi_remove_handle` for any of the above. See section
[No-blocking curl_multi_remove_handle](#non-blocking-curl_multi_remove_handle)
- Calling `curl_ws_send()` from a callback</p>
<h3 id="Better_support_for_same_name_res">Better support for same name resolves</h3>
<p>If a name resolve has been initiated for name NN and a second easy handle
wants to resolve that name as well, make it wait for the first resolve to end
up in the cache instead of doing a second separate resolve. This is
especially needed when adding many simultaneous handles using the same host
name when the DNS resolver can get flooded.</p>
<h3 id="Non_blocking_curl_multi_remove_h">Non-blocking curl_multi_remove_handle()</h3>
<p>The multi interface has a few API calls that assume a blocking behavior, like
`add_handle()` and `remove_handle()` which limits what we can do internally.
The multi API need to be moved even more into a single function that "drives"
everything in a non-blocking manner and signals when something is done. A
remove or add would then only ask for the action to get started and then
`multi_perform()` etc still be called until the add/remove is completed.</p>
<h3 id="Split_connect_and_authentication">Split connect and authentication process</h3>
<p>The multi interface treats the authentication process as part of the connect
phase. As such any failures during authentication does not trigger the
relevant QUIT or LOGOFF for protocols such as IMAP, POP3 and SMTP.</p>
<h3 id="Edge_triggered_sockets_should_wo">Edge-triggered sockets should work</h3>
<p>The `multi_socket` API should work with edge-triggered socket events. One of
the internal actions that need to be improved for this to work perfectly is
the `maxloops` handling in `transfer.c:readwrite_data()`.</p>
<h3 id="multi_upkeep">multi upkeep</h3>
<p>In libcurl 7.62.0 we introduced `curl_easy_upkeep`. It unfortunately only works
on easy handles. We should introduces a version of that for the multi handle,
and also consider doing "upkeep" automatically on connections in the
connection pool when the multi handle is in used.</p>
<p>See <a href="https://github.com/curl/curl/issues/3199">curl/curl#3199</a></p>
<h3 id="Virtual_external_sockets">Virtual external sockets</h3>
<p>libcurl performs operations on the given file descriptor that presumes it is
a socket and an application cannot replace them at the moment. Allowing an
application to fully replace those would allow a larger degree of freedom and
flexibility.</p>
<p>See <a href="https://github.com/curl/curl/issues/5835">curl/curl#5835</a></p>
<h3 id="dynamically_decide_to_use_socket">dynamically decide to use socketpair</h3>
<p>For users who do not use `curl_multi_wait()` or do not care for
`curl_multi_wakeup()`, we could introduce a way to make libcurl NOT
create a socketpair in the multi handle.</p>
<p>See <a href="https://github.com/curl/curl/issues/4829">curl/curl#4829</a></p>
<h2 id="Documentation">Documentation</h2>
<h3 id="Improve_documentation_about_fork">Improve documentation about fork safety</h3>
<p>See <a href="https://github.com/curl/curl/issues/6968">curl/curl#6968</a></p>
<h2 id="FTP">FTP</h2>
<h3 id="HOST">HOST</h3>
<p>HOST is a command for a client to tell which hostname to use, to offer FTP
servers named-based virtual hosting.</p>
<p>See https://datatracker.ietf.org/doc/html/rfc7151</p>
<h3 id="A_fixed_directory_listing_format">A fixed directory listing format</h3>
<p>Since listing the contents of a remove directory with FTP is returning the
list in a format and style the server likes without any estblished or even
defactor standard existing, it would be a feature to users if curl could
parse the directory listing and output a general curl format that is fixed
and the same, independent of the server's choice. This would allow users to
better and more reliably extract information about remote content via FTP
directory listings.</p>
<h3 id="GSSAPI_via_Windows_SSPI">GSSAPI via Windows SSPI</h3>
<p>In addition to currently supporting the SASL GSSAPI mechanism (Kerberos V5)
via third-party GSS-API libraries, such as MIT Kerberos, also add support
for GSSAPI authentication via Windows SSPI.</p>
<h3 id="STAT_for_LIST_without_data_conne">STAT for LIST without data connection</h3>
<p>Some FTP servers allow STAT for listing directories instead of using LIST,
and the response is then sent over the control connection instead of as the
otherwise usedw data connection.</p>
<p>See https://www.nsftools.com/tips/RawFTP.htm#STAT</p>
<p>This is not detailed in any FTP specification.</p>
<h3 id="Passive_transfer_could_try_other">Passive transfer could try other IP addresses</h3>
<p>When doing FTP operations through a proxy at localhost, the reported spotted
that curl only tried to connect once to the proxy, while it had multiple
addresses and a failed connect on one address should make it try the next.</p>
<p>After switching to passive mode (EPSV), curl could try all IP addresses for
"localhost". Currently it tries ::1, but it should also try 127.0.0.1.</p>
<p>See <a href="https://github.com/curl/curl/issues/1508">curl/curl#1508</a></p>
<h2 id="HTTP">HTTP</h2>
<h3 id="Provide_the_error_body_from_a_CO">Provide the error body from a CONNECT response</h3>
<p>When curl receives a body response from a CONNECT request to a proxy, it
always just reads and ignores it. It would make some users happy if curl
instead optionally would be able to make that responsible available. Via a
new callback? Through some other means?</p>
<p>See <a href="https://github.com/curl/curl/issues/9513">curl/curl#9513</a></p>
<h3 id="Obey_Retry_After_in_redirects">Obey Retry-After in redirects</h3>
<p>The `Retry-After` is said to dictate "the minimum time that the user agent is
asked to wait before issuing the redirected request" and libcurl does not
obey this.</p>
<p>See <a href="https://github.com/curl/curl/issues/11447">curl/curl#11447</a></p>
<h3 id="Rearrange_request_header_order">Rearrange request header order</h3>
<p>Server implementers often make an effort to detect browser and to reject
clients it can detect to not match. One of the last details we cannot yet
control in libcurl's HTTP requests, which also can be exploited to detect
that libcurl is in fact used even when it tries to impersonate a browser, is
the order of the request headers. I propose that we introduce a new option in
which you give headers a value, and then when the HTTP request is built it
sorts the headers based on that number. We could then have internally created
headers use a default value so only headers that need to be moved have to be
specified.</p>
<h3 id="Allow_SAN_names_in_HTTP_2_server">Allow SAN names in HTTP/2 server push</h3>
<p>curl only allows HTTP/2 push promise if the provided :authority header value
exactly matches the hostname given in the URL. It could be extended to allow
any name that would match the Subject Alternative Names in the server's TLS
certificate.</p>
<p>See <a href="https://github.com/curl/curl/pull/3581">curl/curl#3581</a></p>
<h3 id="auth_in_URLs">auth= in URLs</h3>
<p>Add the ability to specify the preferred authentication mechanism to use by
using ;auth=\<mech\> in the login part of the URL.</p>
<p>For example:</p>
<p>`http://test:pass;auth=NTLM@example.com` would be equivalent to specifying
`--user test:pass;auth=NTLM` or `--user test:pass --ntlm` from the command
line.</p>
<p>Additionally this should be implemented for proxy base URLs as well.</p>
<h3 id="alt_svc_should_fallback_if_alt_s">alt-svc should fallback if alt-svc does not work</h3>
<p>The alt-svc: header provides a set of alternative services for curl to use
instead of the original. If the first attempted one fails, it should try the
next etc and if all alternatives fail go back to the original.</p>
<p>See <a href="https://github.com/curl/curl/issues/4908">curl/curl#4908</a></p>
<h3 id="Require_HTTP_version_X_or_higher">Require HTTP version X or higher</h3>
<p>curl and libcurl provide options for trying higher HTTP versions (for example
HTTP/2) but then still allows the server to pick version 1.1. We could
consider adding a way to require a minimum version.</p>
<p>See <a href="https://github.com/curl/curl/issues/7980">curl/curl#7980</a></p>
<h2 id="TELNET">TELNET</h2>
<h3 id="ditch_stdin">ditch stdin</h3>
<p>Reading input (to send to the remote server) on stdin is a crappy solution
for library purposes. We need to invent a good way for the application to be
able to provide the data to send.</p>
<h3 id="ditch_telnet_specific_select">ditch telnet-specific select</h3>
<p>Move the telnet support's network select() loop go away and merge the code
into the main transfer loop. Until this is done, the multi interface does not
work for telnet.</p>
<h3 id="feature_negotiation_debug_data">feature negotiation debug data</h3>
<p>Add telnet feature negotiation data to the debug callback as header data.</p>
<h3 id="exit_immediately_upon_connection">exit immediately upon connection if stdin is /dev/null</h3>
<p>If it did, curl could be used to probe if there is an server there listening
on a specific port. That is, the following command would exit immediately
after the connection is established with exit code 0:</p>
<p>    curl -s --connect-timeout 2 telnet://example.com:80 </dev/null</p>
<h2 id="SMTP">SMTP</h2>
<h3 id="Passing_NOTIFY_option_to_CURLOPT">Passing NOTIFY option to CURLOPT_MAIL_RCPT</h3>
<p>Is there a way to pass the NOTIFY option to the `CURLOPT_MAIL_RCPT` option ?  I
set a string that already contains a bracket. For instance something like
that: `curl_slist_append( recipients, "<foo@bar> NOTIFY=SUCCESS,FAILURE" );`</p>
<p>See <a href="https://github.com/curl/curl/issues/8232">curl/curl#8232</a></p>
<h3 id="Enhanced_capability_support">Enhanced capability support</h3>
<p>Add the ability, for an application that uses libcurl, to obtain the list of
capabilities returned from the EHLO command.</p>
<h3 id="Add_CURLOPT_MAIL_CLIENT_option">Add CURLOPT_MAIL_CLIENT option</h3>
<p>Rather than use the URL to specify the mail client string to present in the
HELO and EHLO commands, libcurl should support a new `CURLOPT` specifically for
specifying this data as the URL is non-standard and to be honest a bit of a
hack ;-)</p>
<p>See https://curl.se/mail/lib-2012-05/0178.html</p>
<h2 id="POP3">POP3</h2>
<h3 id="Enhanced_capability_support">Enhanced capability support</h3>
<p>Add the ability, for an application that uses libcurl, to obtain the list of
capabilities returned from the CAPA command.</p>
<h2 id="IMAP">IMAP</h2>
<h3 id="Enhanced_capability_support">Enhanced capability support</h3>
<p>Add the ability, for an application that uses libcurl, to obtain the list of
capabilities returned from the CAPABILITY command.</p>
<h2 id="LDAP">LDAP</h2>
<h3 id="SASL_based_authentication_mechan">SASL based authentication mechanisms</h3>
<p>Currently the LDAP module only supports `ldap_simple_bind_s()` in order to bind
to an LDAP server. However, this function sends username and password details
using the simple authentication mechanism (as clear text). However, it should
be possible to use `ldap_bind_s()` instead specifying the security context
information ourselves.</p>
<h3 id="CURLOPT_SSL_CTX_FUNCTION_for_LDA">CURLOPT_SSL_CTX_FUNCTION for LDAPS</h3>
<p>CURLOPT_SSL_CTX_FUNCTION works perfectly for HTTPS and email protocols, but
it has no effect for LDAPS connections.</p>
<p>See <a href="https://github.com/curl/curl/issues/4108">curl/curl#4108</a></p>
<h3 id="Paged_searches_on_LDAP_server">Paged searches on LDAP server</h3>
<p>See <a href="https://github.com/curl/curl/issues/4452">curl/curl#4452</a></p>
<h3 id="Certificate_Based_Authentication">Certificate-Based Authentication</h3>
<p>LDAPS not possible with macOS and Windows with Certificate-Based Authentication</p>
<p>See <a href="https://github.com/curl/curl/issues/9641">curl/curl#9641</a></p>
<h2 id="SMB">SMB</h2>
<h3 id="File_listing_support">File listing support</h3>
<p>Add support for listing the contents of an SMB share. The output should
probably be the same as/similar to FTP.</p>
<h3 id="Honor_file_timestamps">Honor file timestamps</h3>
<p>The timestamp of the transferred file should reflect that of the original
file.</p>
<h3 id="Use_NTLMv2">Use NTLMv2</h3>
<p>Currently the SMB authentication uses NTLMv1.</p>
<h3 id="Create_remote_directories">Create remote directories</h3>
<p>Support for creating remote directories when uploading a file to a directory
that does not exist on the server, just like `--ftp-create-dirs`.</p>
<h2 id="FILE">FILE</h2>
<h3 id="Directory_listing_on_non_POSIX">Directory listing on non-POSIX</h3>
<p>Listing the contents of a directory accessed with FILE only works on
platforms with `opendir`. Support could be added for more systems, like
Windows.</p>
<h2 id="TLS">TLS</h2>
<h3 id="TLS_PSK_with_OpenSSL">TLS-PSK with OpenSSL</h3>
<p>Transport Layer Security pre-shared key ciphersuites (TLS-PSK) is a set of
cryptographic protocols that provide secure communication based on pre-shared
keys (PSKs). These pre-shared keys are symmetric keys shared in advance among
the communicating parties.</p>
<p>See <a href="https://github.com/curl/curl/issues/5081">curl/curl#5081</a></p>
<h3 id="TLS_channel_binding">TLS channel binding</h3>
<p>TLS 1.2 and 1.3 provide the ability to extract some secret data from the TLS
connection and use it in the client request (usually in some sort of
authentication) to ensure that the data sent is bound to the specific TLS
connection and cannot be successfully intercepted by a proxy. This
functionality can be used in a standard authentication mechanism such as
GSS-API or SCRAM, or in custom approaches like custom HTTP Authentication
headers.</p>
<p>For TLS 1.2, the binding type is usually tls-unique, and for TLS 1.3 it is
tls-exporter. See:</p>
<p>- https://datatracker.ietf.org/doc/html/rfc5929
- https://datatracker.ietf.org/doc/html/rfc9266
- <a href="https://github.com/curl/curl/issues/9226">curl/curl#9226</a></p>
<h3 id="Defeat_TLS_fingerprinting">Defeat TLS fingerprinting</h3>
<p>By changing the order of TLS extensions provided in the TLS handshake, it is
sometimes possible to circumvent TLS fingerprinting by servers. The TLS
extension order is of course not the only way to fingerprint a client.</p>
<h3 id="Consider_OCSP_stapling_by_defaul">Consider OCSP stapling by default</h3>
<p>Treat a negative response a reason for aborting the connection. Since OCSP
stapling is presumed to get used much less in the future when Let's Encrypt
drops the OCSP support, the benefit of this might however be limited.</p>
<p>See <a href="https://github.com/curl/curl/issues/15483">curl/curl#15483</a></p>
<h3 id="Provide_callback_for_cert_verifi">Provide callback for cert verification</h3>
<p>OpenSSL supports a callback for customised verification of the peer
certificate, but this does not seem to be exposed in the libcurl APIs. Could
it be? There is so much that could be done if it were.</p>
<h3 id="Less_memory_massaging_with_Schan">Less memory massaging with Schannel</h3>
<p>The Schannel backend does a lot of custom memory management we would rather
avoid: the repeated alloc + free in sends and the custom memory + realloc
system for encrypted and decrypted data. That should be avoided and reduced
for 1) efficiency and 2) safety.</p>
<h3 id="Support_DANE">Support DANE</h3>
<p>DNS-Based Authentication of Named Entities (DANE) is a way to provide SSL
keys and certs over DNS using DNSSEC as an alternative to the CA model.</p>
<p>See https://www.rfc-editor.org/rfc/rfc6698.txt</p>
<p>An [initial patch](https://curl.se/mail/lib-2013-03/0075.html) was posted by
Suresh Krishnaswamy on March 7th 2013 but it was a too simple approach.</p>
<p>See [Daniel's comments:](https://curl.se/mail/lib-2013-03/0103.html).</p>
<p>`libunbound` may be the correct library to base this development on.</p>
<p>Bj√∂rn Stenberg wrote a separate initial take on DANE that was never
completed.</p>
<h3 id="TLS_record_padding">TLS record padding</h3>
<p>TLS (1.3) offers optional record padding and OpenSSL provides an API for it.
I could make sense for libcurl to offer this ability to applications to make
traffic patterns harder to figure out by network traffic observers.</p>
<p>See <a href="https://github.com/curl/curl/issues/5398">curl/curl#5398</a></p>
<h3 id="Support_Authority_Information_Ac">Support Authority Information Access certificate extension (AIA)</h3>
<p>AIA can provide various things like CRLs but more importantly information
about intermediate CA certificates that can allow validation path to be
fulfilled when the HTTPS server does not itself provide them.</p>
<p>Since AIA is about downloading certs on demand to complete a TLS handshake,
it is probably a bit tricky to get done right.</p>
<p>See <a href="https://github.com/curl/curl/issues/2793">curl/curl#2793</a></p>
<h3 id="Some_TLS_options_are_not_offered">Some TLS options are not offered for HTTPS proxies</h3>
<p>Some TLS related options to the command line tool and libcurl are only
provided for the server and not for HTTPS proxies. `--proxy-tls-max`,
`--proxy-tlsv1.3`, `--proxy-curves` and a few more. See:</p>
<p>- https://curl.se/libcurl/c/tls-options.html
- <a href="https://github.com/curl/curl/issues/12286">curl/curl#12286</a></p>
<h3 id="Make_sure_we_forbid_TLS_1_3_post">Make sure we forbid TLS 1.3 post-handshake authentication</h3>
<p>RFC 8740 explains how using HTTP/2 must forbid the use of TLS 1.3
post-handshake authentication. We should make sure to live up to that.</p>
<p>See <a href="https://github.com/curl/curl/issues/5396">curl/curl#5396</a></p>
<h3 id="Support_the_clienthello_extensio">Support the clienthello extension</h3>
<p>Certain stupid networks and middle boxes have a problem with SSL handshake
packets that are within a certain size range because how that sets some bits
that previously (in older TLS version) were not set. The clienthello
extension adds padding to avoid that size range. See:</p>
<p>- https://datatracker.ietf.org/doc/html/rfc7685
- <a href="https://github.com/curl/curl/issues/2299">curl/curl#2299</a></p>
<h3 id="Share_the_CA_cache">Share the CA cache</h3>
<p>For TLS backends that supports CA caching, it makes sense to allow the share
object to be used to store the CA cache as well via the share API. Would
allow multiple easy handles to reuse the CA cache and save themselves from a
lot of extra processing overhead.</p>
<h3 id="Add_missing_features_to_TLS_back">Add missing features to TLS backends</h3>
<p>The feature matrix at
[curl.se/tls-options](https://curl.se/libcurl/c/tls-options.html) shows which
features are supported by which TLS backends, and thus also where there are
feature gaps.</p>
<h2 id="Proxy">Proxy</h2>
<h3 id="Retry_SOCKS_handshake_on_address">Retry SOCKS handshake on address type not supported</h3>
<p>When curl resolves a hostname, it might get a mix of IPv6 and IPv4 returned.
curl might then use an IPv6 address with a SOCKS5 proxy, which - if it does
not support IPv6 - returns "Address type not supported" and curl exits with
that error.</p>
<p>Perhaps it is preferred if curl would in this situation instead first retry
the SOCKS handshake again for this case and then use one of the IPv4
addresses for the target host.</p>
<p>See <a href="https://github.com/curl/curl/issues/17222">curl/curl#17222</a></p>
<h2 id="Schannel">Schannel</h2>
<h3 id="Extend_support_for_client_certif">Extend support for client certificate authentication</h3>
<p>The existing support for the `-E/--cert` and `--key` options could be
extended by supplying a custom certificate and key in PEM format.</p>
<p>See
https://learn.microsoft.com/en-us/windows/win32/secauthn/getting-a-certificate-for-schannel</p>
<h3 id="Extend_support_for_the_ciphers">Extend support for the --ciphers option</h3>
<p>The existing support for the `--ciphers` option could be extended
by mapping the OpenSSL/GnuTLS cipher suites to the Schannel APIs.</p>
<p>See
https://learn.microsoft.com/en-us/windows/win32/secauthn/specifying-schannel-ciphers-and-cipher-strengths</p>
<h3 id="Add_option_to_allow_abrupt_serve">Add option to allow abrupt server closure</h3>
<p>libcurl with Schannel errors without a known termination point from the server
(such as length of transfer, or SSL "close notify" alert) to prevent against
a truncation attack. Really old servers may neglect to send any termination
point. An option could be added to ignore such abrupt closures.</p>
<p>See <a href="https://github.com/curl/curl/issues/4427">curl/curl#4427</a></p>
<h2 id="SASL">SASL</h2>
<h3 id="Other_authentication_mechanisms">Other authentication mechanisms</h3>
<p>Add support for other authentication mechanisms such as OLP,
GSS-SPNEGO and others.</p>
<h3 id="Add_QOP_support_to_GSSAPI_authen">Add QOP support to GSSAPI authentication</h3>
<p>Currently the GSSAPI authentication only supports the default QOP of auth
(Authentication), whilst Kerberos V5 supports both auth-int (Authentication
with integrity protection) and auth-conf (Authentication with integrity and
privacy protection).</p>
<h2 id="SSH-protocols">SSH protocols</h2>
<h3 id="Multiplexing">Multiplexing</h3>
<p>SSH is a perfectly fine multiplexed protocols which would allow libcurl to do
multiple parallel transfers from the same host using the same connection,
much in the same spirit as HTTP/2 does. libcurl however does not take
advantage of that ability but does instead always create a new connection for
new transfers even if an existing connection already exists to the host.</p>
<p>To fix this, libcurl would have to detect an existing connection and "attach"
the new transfer to the existing one.</p>
<h3 id="Handle_growing_SFTP_files">Handle growing SFTP files</h3>
<p>The SFTP code in libcurl checks the file size *before* a transfer starts and
then proceeds to transfer exactly that amount of data. If the remote file
grows while the transfer is in progress libcurl does not notice and does not
adapt. The OpenSSH SFTP command line tool does and libcurl could also just
attempt to download more to see if there is more to get...</p>
<p>See <a href="https://github.com/curl/curl/issues/4344">curl/curl#4344</a></p>
<h3 id="Read_keys_from_ssh_id_ecdsa">Read keys from ~/.ssh/id_ecdsa, id_ed25519</h3>
<p>The libssh2 backend in curl is limited to only reading keys from `id_rsa` and
`id_dsa`, which makes it fail connecting to servers that use more modern key
types.</p>
<p>See <a href="https://github.com/curl/curl/issues/8586">curl/curl#8586</a></p>
<h3 id="Support_CURLOPT_PREQUOTE">Support CURLOPT_PREQUOTE</h3>
<p>The two other QUOTE options are supported for SFTP, but this was left out for
unknown reasons.</p>
<h3 id="SSH_over_HTTPS_proxy_with_more_b">SSH over HTTPS proxy with more backends</h3>
<p>The SSH based protocols SFTP and SCP did not work over HTTPS proxy at
all until PR <a href="https://github.com/curl/curl/pull/6021">curl/curl#6021</a> brought the
functionality with the libssh2 backend. Presumably, this support
can/could be added for the other backends as well.</p>
<h3 id="SFTP_with_SCP">SFTP with SCP://</h3>
<p>OpenSSH 9 switched their 'scp' tool to speak SFTP under the hood. Going
forward it might be worth having curl or libcurl attempt SFTP if SCP fails to
follow suite.</p>
<h2 id="Command-line-tool">Command line tool</h2>
<h3 id="sync">sync</h3>
<p>    curl --sync http://example.com/feed[1-100].rss
#or 
    curl --sync http://example.net/{index,calendar,history}.html</p>
<p>Downloads a range or set of URLs using the remote name, but only if the
remote file is newer than the local file. A `Last-Modified` HTTP date header
should also be used to set the mod date on the downloaded file.</p>
<h3 id="glob_posts">glob posts</h3>
<p>Globbing support for `-d` and `-F`, as in `curl -d "name=foo[0-9]" URL`.
This is easily scripted though.</p>
<h3 id="proxycommand">--proxycommand</h3>
<p>Allow the user to make curl run a command and use its stdio to make requests
and not do any network connection by itself. Example:</p>
<p>    curl --proxycommand 'ssh pi@raspberrypi.local -W 10.1.1.75 80'          http://some/otherwise/unavailable/service.php</p>
<p>See <a href="https://github.com/curl/curl/issues/4941">curl/curl#4941</a></p>
<h3 id="UTF_8_filenames_in_Content_Dispo">UTF-8 filenames in Content-Disposition</h3>
<p>RFC 6266 documents how UTF-8 names can be passed to a client in the
Content-Disposition header, and curl does not support this.</p>
<p>See <a href="https://github.com/curl/curl/issues/1888">curl/curl#1888</a></p>
<h3 id="Option_to_make_Z_merge_lined_ba">Option to make -Z merge lined based outputs on stdout</h3>
<p>When a user requests multiple lined based files using `-Z` and sends them to
stdout, curl does not "merge" and send complete lines fine but may send
partial lines from several sources.</p>
<p>See <a href="https://github.com/curl/curl/issues/5175">curl/curl#5175</a></p>
<h3 id="specify_which_response_codes_tha">specify which response codes that make -f/--fail return error</h3>
<p>Allows a user to better specify exactly which error code(s) that are fine
and which are errors for their specific uses cases</p>
<h3 id="Choose_the_name_of_file_in_brace">Choose the name of file in braces for complex URLs</h3>
<p>When using braces to download a list of URLs and you use complicated names
in the list of alternatives, it could be handy to allow curl to use other
names when saving.</p>
<p>Consider a way to offer that. Possibly like
{partURL1:name1,partURL2:name2,partURL3:name3} where the name following the
colon is the output name.</p>
<p>See <a href="https://github.com/curl/curl/issues/221">curl/curl#221</a></p>
<h3 id="improve_how_curl_works_in_a_Wind">improve how curl works in a Windows console window</h3>
<p>If you pull the scrollbar when transferring with curl in a Windows console
window, the transfer is interrupted and can get disconnected. This can
probably be improved.</p>
<p>See <a href="https://github.com/curl/curl/issues/322">curl/curl#322</a></p>
<h3 id="Windows_set_attribute_archive">Windows: set attribute 'archive' for completed downloads</h3>
<p>The archive bit (FILE_ATTRIBUTE_ARCHIVE, 0x20) separates files that shall be
backed up from those that are either not ready or have not changed.</p>
<p>Downloads in progress are neither ready to be backed up, nor should they be
opened by a different process. Only after a download has been completed it is
sensible to include it in any integer snapshot or backup of the system.</p>
<p>See <a href="https://github.com/curl/curl/issues/3354">curl/curl#3354</a></p>
<h3 id="keep_running_read_instructions">keep running, read instructions from pipe/socket</h3>
<p>Provide an option that makes curl not exit after the last URL (or even work
without a given URL), and then make it read instructions passed on a pipe or
over a socket to make further instructions so that a second subsequent curl
invoke can talk to the still running instance and ask for transfers to get
done, and thus maintain its connection pool, DNS cache and more.</p>
<h3 id="Acknowledge_Ratelimit_headers">Acknowledge Ratelimit headers</h3>
<p>Consider a command line option that can make curl do multiple serial requests
while acknowledging server specified rate limits. See:</p>
<p>- https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/
- <a href="https://github.com/curl/curl/issues/5406">curl/curl#5406</a></p>
<h3 id="dry_run">--dry-run</h3>
<p>A command line option that makes curl show exactly what it would do and send
if it would run for real.</p>
<p>See <a href="https://github.com/curl/curl/issues/5426">curl/curl#5426</a></p>
<h3 id="retry_should_resume">--retry should resume</h3>
<p>When `--retry` is used and curl actually retries transfer, it should use the
already transferred data and do a resumed transfer for the rest (when
possible) so that it does not have to transfer the same data again that was
already transferred before the retry.</p>
<p>See <a href="https://github.com/curl/curl/issues/1084">curl/curl#1084</a></p>
<h3 id="consider_filename_from_the_redir">consider filename from the redirected URL with -O ?</h3>
<p>When a user gives a URL and uses `-O`, and curl follows a redirect to a new
URL, the filename is not extracted and used from the newly redirected-to URL
even if the new URL may have a much more sensible filename.</p>
<p>This is clearly documented and helps for security since there is no surprise
to users which filename that might get overwritten, but maybe a new option
could allow for this or maybe `-J` should imply such a treatment as well as
`-J` already allows for the server to decide what filename to use so it
already provides the "may overwrite any file" risk.</p>
<p>This is extra tricky if the original URL has no filename part at all since
then the current code path does error out with an error message, and we
cannot *know* already at that point if curl is redirected to a URL that has a
filename...</p>
<p>See <a href="https://github.com/curl/curl/issues/1241">curl/curl#1241</a></p>
<h3 id="retry_on_network_is_unreachable">retry on network is unreachable</h3>
<p>The `--retry` option retries transfers on "transient failures". We later added
`--retry-connrefused` to also retry for "connection refused" errors.</p>
<p>Suggestions have been brought to also allow retry on "network is unreachable"
errors and while totally reasonable, maybe we should consider a way to make
this more configurable than to add a new option for every new error people
want to retry for?</p>
<p>See <a href="https://github.com/curl/curl/issues/1603">curl/curl#1603</a></p>
<h3 id="hostname_sections_in_config_file">hostname sections in config files</h3>
<p>config files would be more powerful if they could set different
configurations depending on used URLs, hostname or possibly origin. Then a
default `.curlrc` could a specific user-agent only when doing requests against
a certain site.</p>
<h3 id="retry_on_the_redirected_to_URL">retry on the redirected-to URL</h3>
<p>When curl is told to `--retry` a failed transfer and follows redirects, it
might get an HTTP 429 response from the redirected-to URL and not the
original one, which then could make curl decide to rather retry the transfer
on that URL only instead of the original operation to the original URL.</p>
<p>Perhaps extra emphasized if the original transfer is a large POST that
redirects to a separate GET, and that GET is what gets the 529</p>
<p>See <a href="https://github.com/curl/curl/issues/5462">curl/curl#5462</a></p>
<h3 id="Set_the_modification_date_on_an">Set the modification date on an uploaded file</h3>
<p>For SFTP and possibly FTP, curl could offer an option to set the
modification time for the uploaded file.</p>
<p>See <a href="https://github.com/curl/curl/issues/5768">curl/curl#5768</a></p>
<h3 id="Use_multiple_parallel_transfers">Use multiple parallel transfers for a single download</h3>
<p>To enhance transfer speed, downloading a single URL can be split up into
multiple separate range downloads that get combined into a single final
result.</p>
<p>An ideal implementation would not use a specified number of parallel
transfers, but curl could:</p>
<p>- First start getting the full file as transfer A
- If after N seconds have passed and the transfer is expected to continue for
  M seconds or more, add a new transfer (B) that asks for the second half of
  A's content (and stop A at the middle).
- If splitting up the work improves the transfer rate, it could then be done
  again. Then again, etc up to a limit.</p>
<p>This way, if transfer B fails (because `Range:` is not supported) it lets
transfer A remain the single one. N and M could be set to some sensible
defaults.</p>
<p>See <a href="https://github.com/curl/curl/issues/5774">curl/curl#5774</a></p>
<h3 id="Prevent_terminal_injection_when">Prevent terminal injection when writing to terminal</h3>
<p>curl could offer an option to make escape sequence either non-functional or
avoid cursor moves or similar to reduce the risk of a user getting tricked by
clever tricks.</p>
<p>See <a href="https://github.com/curl/curl/issues/6150">curl/curl#6150</a></p>
<h3 id="Custom_progress_meter_update_int">Custom progress meter update interval</h3>
<p>Users who are for example doing large downloads in CI or remote setups might
want the occasional progress meter update to see that the transfer is
progressing and has not stuck, but they may not appreciate the
many-times-a-second frequency curl can end up doing it with now.</p>
<h3 id="J_and_O_with_encoded_filenam">-J and -O with %-encoded filenames</h3>
<p>`-J/--remote-header-name` does not decode %-encoded filenames. RFC 6266 details
how it should be done. The can of worm is basically that we have no charset
handling in curl and ASCII >=128 is a challenge for us. Not to mention that
decoding also means that we need to check for nastiness that is attempted,
like "../" sequences and the like. Probably everything to the left of any
embedded slashes should be cut off.</p>
<p>See https://curl.se/bug/view.cgi?id=1294</p>
<p>`-O` also does not decode %-encoded names, and while it has even less
information about the charset involved the process is similar to the `-J` case.</p>
<p>Note that we do not decode `-O` without the user asking for it with some other
means, since `-O` has always been documented to use the name exactly as
specified in the URL.</p>
<h3 id="J_with_C">-J with -C -</h3>
<p>When using `-J` (with `-O`), automatically resumed downloading together with
`-C -` fails. Without `-J` the same command line works. This happens because
the resume logic is worked out before the target filename (and thus its
pre-transfer size) has been figured out. This can be improved.</p>
<p>See https://curl.se/bug/view.cgi?id=1169</p>
<h3 id="retry_and_transfer_timeouts">--retry and transfer timeouts</h3>
<p>If using `--retry` and the transfer timeouts (possibly due to using `-m` or
`-y/-Y`) the next attempt does not resume the transfer properly from what was
downloaded in the previous attempt but truncates and restarts at the original
position where it was at before the previous failed attempt.</p>
<p>See https://curl.se/mail/lib-2008-01/0080.html</p>
<h2 id="Build">Build</h2>
<h3 id="Enable_PIE_and_RELRO_by_default">Enable PIE and RELRO by default</h3>
<p>Especially when having programs that execute curl via the command line, `PIE`
renders the exploitation of memory corruption vulnerabilities a lot more
difficult. This can be attributed to the additional information leaks being
required to conduct a successful attack. `RELRO`, on the other hand, masks
different binary sections like the `GOT` as read-only and thus kills a handful
of techniques that come in handy when attackers are able to arbitrarily
overwrite memory. A few tests showed that enabling these features had close
to no impact, neither on the performance nor on the general functionality of
curl.</p>
<h3 id="Do_not_use_GNU_libtool_on_OpenBS">Do not use GNU libtool on OpenBSD</h3>
<p>When compiling curl on OpenBSD with `--enable-debug` it gives linking errors
when you use GNU `libtool`. This can be fixed by using the `libtool` provided
by OpenBSD itself. However for this the user always needs to invoke make with
`LIBTOOL=/usr/bin/libtool`. It would be nice if the script could have some
magic to detect if this system is an OpenBSD host and then use the OpenBSD
`libtool` instead.</p>
<p>See <a href="https://github.com/curl/curl/issues/5862">curl/curl#5862</a></p>
<h3 id="Package_curl_for_Windows_in_a_si">Package curl for Windows in a signed installer</h3>
<p>See <a href="https://github.com/curl/curl/issues/5424">curl/curl#5424</a></p>
<h3 id="make_configure_use_cache_file">make configure use --cache-file more and better</h3>
<p>The configure script can be improved to cache more values so that repeated
invokes run much faster.</p>
<p>See <a href="https://github.com/curl/curl/issues/7753">curl/curl#7753</a></p>
<h2 id="Test-suite">Test suite</h2>
<h3 id="SSL_tunnel">SSL tunnel</h3>
<p>Make our own version of `stunnel` for simple port forwarding to enable HTTPS
and FTP-SSL tests without the `stunnel` dependency, and it could allow us to
provide test tools built with either OpenSSL or GnuTLS</p>
<h3 id="more_protocols_supported">more protocols supported</h3>
<p>Extend the test suite to include more protocols. The telnet could just do FTP
or http operations (for which we have test servers).</p>
<h3 id="more_platforms_supported">more platforms supported</h3>
<p>Make the test suite work on more platforms. OpenBSD and macOS. Remove
fork()s and it should become even more portable.</p>
<h3 id="write_an_SMB_test_server_to_repl">write an SMB test server to replace impacket</h3>
<p>This would allow us to run SMB tests on more platforms and do better and more
covering tests.</p>
<p>See <a href="https://github.com/curl/curl/issues/15697">curl/curl#15697</a></p>
<h3 id="Use_the_RFC_6265_test_suite">Use the RFC 6265 test suite</h3>
<p>A test suite made for HTTP cookies (RFC 6265) by Adam Barth is available at
[http-state/tests](https://github.com/abarth/http-state/tree/master/tests).</p>
<p>It would be good if someone would write a script/setup that would run curl
with that test suite and detect deviances. Ideally, that would even be
incorporated into our regular test suite.</p>
<h3 id="Run_web_platform_tests_URL_tests">Run web-platform-tests URL tests</h3>
<p>Run web-platform-tests URL tests and compare results with browsers on wpt.fyi</p>
<p>It would help us find issues to fix and help us document where our parser
differs from the WHATWG URL spec parsers.</p>
<p>See <a href="https://github.com/curl/curl/issues/4477">curl/curl#4477</a></p>
<h2 id="MQTT">MQTT</h2>
<h3 id="Support_rate_limiting">Support rate-limiting</h3>
<p>The rate-limiting logic is done in the PERFORMING state in multi.c but MQTT
is not (yet) implemented to use that.</p>
<h3 id="Support_MQTTS">Support MQTTS</h3>
<h3 id="Handle_network_blocks">Handle network blocks</h3>
<p>Running test suite with `CURL_DBG_SOCK_WBLOCK=90 ./runtests.pl -a mqtt` makes
several MQTT test cases fail where they should not.</p>
<h3 id="large_payloads">large payloads</h3>
<p>libcurl unnecessarily allocates heap memory to hold the entire payload to get
sent, when the data is already perfectly accessible where it is when
`CURLOPT_POSTFIELDS` is used. This is highly inefficient for larger payloads.
Additionally, libcurl does not support using the read callback for sending
MQTT which is yet another way to avoid having to hold large payload in
memory.</p>
<h2 id="TFTP">TFTP</h2>
<h3 id="TFTP_does_not_convert_LF_to_CRLF">TFTP does not convert LF to CRLF for mode=netascii</h3>
<p>RFC 3617 defines that an TFTP transfer can be done using "netascii" mode.
curl does not support extracting that mode from the URL nor does it treat
such transfers specifically. It should probably do LF to CRLF translations
for them.</p>
<p>See <a href="https://github.com/curl/curl/issues/12655">curl/curl#12655</a></p>
<h2 id="Gopher">Gopher</h2>
<h3 id="Handle_network_blocks">Handle network blocks</h3>
<p>Running test suite with
`CURL_DBG_SOCK_WBLOCK=90 ./runtests.pl -a 1200 to 1300` makes several
Gopher test cases fail where they should not.</p>
<!--
Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.
SPDX-License-Identifier: curl
-->
<h1 id="curl-todo">curl TODO</h1>
<p>Things to do in project curl. Please tell us what you think,
contribute and send us patches that improve things.</p>
<p>Be aware that these are things that we could do, or have once been
considered things we could do. If you want to work on any of these
areas, please consider bringing it up for discussions first on the
mailing list so that we all agree it is still a good idea for the
project.</p>
<p>All bugs documented in the KNOWN_BUGS document are subject for
fixing.</p>
<h2 id="libcurl">libcurl</h2>
<h3 id="tfo-support-on-windows">TFO support on Windows</h3>
<p>libcurl supports the <code>CURLOPT_TCP_FASTOPEN</code> option since
7.49.0 for Linux and macOS. Windows supports TCP Fast Open starting with
Windows 10, version 1607 and we should add support for it.</p>
<p>TCP Fast Open is supported on several platforms but not on Windows.
Work on this was once started but never finished.</p>
<p>See <a
href="https://github.com/curl/curl/pull/3378">https://github.com/curl/curl/pull/3378</a></p>
<h3 id="consult-appdata-also-for-netrc">Consult %APPDATA% also for
.netrc</h3>
<p><code>%APPDATA%\.netrc</code> is not considered when running on
Windows. should not it?</p>
<p>See <a
href="https://github.com/curl/curl/issues/4016">https://github.com/curl/curl/issues/4016</a></p>
<h3 id="struct-lifreq">struct lifreq</h3>
<p>Use <code>struct lifreq</code> and <code>SIOCGLIFADDR</code> instead
of <code>struct ifreq</code> and <code>SIOCGIFADDR</code> on newer
Solaris versions as they claim the latter is obsolete. To support IPv6
interface addresses for network interfaces properly.</p>
<h3 id="alt-svc-sharing">alt-svc sharing</h3>
<p>The share interface could benefit from allowing the alt-svc cache to
be possible to share between easy handles.</p>
<p>See <a
href="https://github.com/curl/curl/issues/4476">https://github.com/curl/curl/issues/4476</a></p>
<p>The share interface offers <code>CURL_LOCK_DATA_CONNECT</code> to
have multiple easy handle share a connection cache, but due to how
connections are used they are still not thread-safe when used shared.
See:</p>
<ul>
<li><a
href="https://github.com/curl/curl/issues/4915">https://github.com/curl/curl/issues/4915</a></li>
<li><a
href="https://github.com/curl/curl/blob/master/tests/libtest/lib1541.c">lib1541.c</a></li>
</ul>
<p>The share interface offers <code>CURL_LOCK_DATA_HSTS</code> to have
multiple easy handle share an HSTS cache, but this is not
thread-safe.</p>
<h3 id="get-rid-of-path_max">get rid of PATH_MAX</h3>
<p>Having code use and rely on <code>PATH_MAX</code> is not nice.</p>
<p>See <a
href="https://insanecoding.blogspot.com/2007/11/pathmax-simply-isnt.html">https://insanecoding.blogspot.com/2007/11/pathmax-simply-isnt.html</a></p>
<p>Currently the libssh2 SSH based code uses it, but to remove
<code>PATH_MAX</code> from there we need libssh2 to properly tell us
when we pass in a too small buffer and its current API (as of libssh2
1.2.7) does not.</p>
<h3 id="thread-safe-sharing">thread-safe sharing</h3>
<p>Using the share interface users can share some data between easy
handles but several of the sharing options are documented as not safe
and supported to share between multiple concurrent threads. Fixing this
would enable more users to share data in more powerful ways.</p>
<h3 id="auto-detect-proxy">auto-detect proxy</h3>
<p>libcurl could be made to detect the system proxy setup automatically
and use that. On Windows, macOS and Linux desktops for example.</p>
<p>The pull-request to use libproxy for this was deferred due to doubts
on the reliability of the dependency and how to use it.</p>
<p>See <a
href="https://github.com/curl/curl/pull/977">https://github.com/curl/curl/pull/977</a></p>
<p>libdetectproxy is a (C++) library for detecting the proxy on
Windows.</p>
<p>See <a
href="https://github.com/paulharris/libdetectproxy">paulharris/libdetectproxy</a></p>
<h3 id="updated-dns-server-while-running">updated DNS server while
running</h3>
<p>If <code>/etc/resolv.conf</code> gets updated while a program using
libcurl is running, it is may cause name resolves to fail unless
<code>res_init()</code> is called. We should consider calling
<code>res_init()</code> + retry once unconditionally on all name resolve
failures to mitigate against this. Firefox works like that. Note that
Windows does not have <code>res_init()</code> or an alternative.</p>
<p>See <a
href="https://github.com/curl/curl/issues/2251">https://github.com/curl/curl/issues/2251</a></p>
<h3 id="c-ares-and-curlopt_opensocketfunction">c-ares and
CURLOPT_OPENSOCKETFUNCTION</h3>
<p>curl creates most sockets via the
<code>CURLOPT_OPENSOCKETFUNCTION</code> callback and close them with the
<code>CURLOPT_CLOSESOCKETFUNCTION</code> callback. However, c-ares does
not use those functions and instead opens and closes the sockets itself.
This means that when curl passes the c-ares socket to the
<code>CURLMOPT_SOCKETFUNCTION</code> it is not owned by the application
like other sockets.</p>
<p>See <a
href="https://github.com/curl/curl/issues/2734">https://github.com/curl/curl/issues/2734</a></p>
<h3 id="monitor-connections-in-the-connection-pool">Monitor connections
in the connection pool</h3>
<p>libcurl's connection cache or pool holds a number of open connections
for the purpose of possible subsequent connection reuse. It may contain
a few up to a significant amount of connections. Currently, libcurl
leaves all connections as they are and first when a connection is
iterated over for matching or reuse purpose it is verified that it is
still alive.</p>
<p>Those connections may get closed by the server side for idleness or
they may get an HTTP/2 ping from the peer to verify that they are still
alive. By adding monitoring of the connections while in the pool,
libcurl can detect dead connections (and close them) better and earlier,
and it can handle HTTP/2 pings to keep such ones alive even when not
actively doing transfers on them.</p>
<h3 id="try-to-url-encode-given-url">Try to URL encode given URL</h3>
<p>Given a URL that for example contains spaces, libcurl could have an
option that would try somewhat harder than it does now and convert
spaces to <code>%20</code> and perhaps URL encoded byte values over 128
etc (basically do what the redirect following code already does).</p>
<p>See <a
href="https://github.com/curl/curl/issues/514">https://github.com/curl/curl/issues/514</a></p>
<h3 id="add-support-for-iris">Add support for IRIs</h3>
<p>IRIs (RFC 3987) allow localized, non-ASCII, names in the URL. To
properly support this, curl/libcurl would need to translate/encode the
given input from the input string encoding into percent encoded output
"over the wire".</p>
<p>To make that work smoothly for curl users even on Windows, curl would
probably need to be able to convert from several input encodings.</p>
<h3 id="try-next-proxy-if-one-does-not-work">try next proxy if one does
not work</h3>
<p>Allow an application to specify a list of proxies to try, and failing
to connect to the first go on and try the next instead until the list is
exhausted. Browsers support this feature at least when they specify
proxies using PACs.</p>
<p>See <a
href="https://github.com/curl/curl/issues/896">https://github.com/curl/curl/issues/896</a></p>
<h3 id="provide-timing-info-for-each-redirect">provide timing info for
each redirect</h3>
<p>curl and libcurl provide timing information via a set of different
time-stamps (<code>CURLINFO_*_TIME</code>). When curl is following
redirects, those returned time value are the accumulated sums. An
improvement could be to offer separate timings for each redirect.</p>
<p>See <a
href="https://github.com/curl/curl/issues/6743">https://github.com/curl/curl/issues/6743</a></p>
<h3 id="srv-and-uri-dns-records">SRV and URI DNS records</h3>
<p>Offer support for resolving SRV and URI DNS records for libcurl to
know which server to connect to for various protocols (including
HTTP).</p>
<h3 id="curlinfo_pause_state">CURLINFO_PAUSE_STATE</h3>
<p>Return information about the transfer's current pause state, in both
directions.</p>
<p>See <a
href="https://github.com/curl/curl/issues/2588">https://github.com/curl/curl/issues/2588</a></p>
<h3 id="expose-tried-ip-addresses-that-failed">Expose tried IP addresses
that failed</h3>
<p>When libcurl fails to connect to a host, it could offer the
application the addresses that were used in the attempt. Source + dest
IP, source + dest port and protocol (UDP or TCP) for each failure.
Possibly as a callback. Perhaps also provide "reason".</p>
<p>See <a
href="https://github.com/curl/curl/issues/2126">https://github.com/curl/curl/issues/2126</a></p>
<h3 id="config-file-parsing">config file parsing</h3>
<p>Consider providing an API, possibly in a separate companion library,
for parsing a config file like curl's -K/--config option to allow
applications to get the same ability to read curl options from
files.</p>
<p>See <a
href="https://github.com/curl/curl/issues/3698">https://github.com/curl/curl/issues/3698</a></p>
<h3 id="erase-secrets-from-heapstack-after-use">erase secrets from
heap/stack after use</h3>
<p>Introducing a concept and system to erase secrets from memory after
use, it could help mitigate and lessen the impact of (future) security
problems etc. However: most secrets are passed to libcurl as clear text
from the application and then clearing them within the library adds
nothing.</p>
<p>See <a
href="https://github.com/curl/curl/issues/7268">https://github.com/curl/curl/issues/7268</a></p>
<h3 id="add-asynch-getaddrinfo-support">add asynch getaddrinfo
support</h3>
<p>Use <code>getaddrinfo_a()</code> to provide an asynch name resolver
backend to libcurl that does not use threads and does not depend on
c-ares. The <code>getaddrinfo_a</code> function is (probably?) glibc
specific but that is a widely used libc among our users.</p>
<p>See <a
href="https://github.com/curl/curl/pull/6746">https://github.com/curl/curl/pull/6746</a></p>
<h3 id="make-doh-inherit-more-transfer-properties">make DoH inherit more
transfer properties</h3>
<p>Some options are not inherited because they are not relevant for the
DoH SSL connections, or inheriting the option may result in unexpected
behavior. For example the user's debug function callback is not
inherited because it would be unexpected for internal handles (ie DoH
handles) to be passed to that callback.</p>
<p>If an option is not inherited then it is not possible to set it
separately for DoH without a DoH-specific option. For example:
<code>CURLOPT_DOH_SSL_VERIFYHOST</code>,
<code>CURLOPT_DOH_SSL_VERIFYPEER</code> and
<code>CURLOPT_DOH_SSL_VERIFYSTATUS</code>.</p>
<p>See <a
href="https://github.com/curl/curl/issues/6605">https://github.com/curl/curl/issues/6605</a></p>
<h2 id="libcurl---multi-interface">libcurl - multi interface</h2>
<h3 id="more-non-blocking">More non-blocking</h3>
<p>Make sure we do not ever loop because of non-blocking sockets
returning <code>EWOULDBLOCK</code> or similar. Blocking cases
include:</p>
<ul>
<li>Name resolves on non-Windows unless c-ares or the threaded resolver
is used.</li>
<li>The threaded resolver may block on cleanup:
<ul>
<li>See <a
href="https://github.com/curl/curl/issues/4852">https://github.com/curl/curl/issues/4852</a></li>
</ul></li>
<li>file:// transfers</li>
<li>TELNET transfers</li>
<li>GSSAPI authentication for FTP transfers</li>
<li>The "DONE" operation (post transfer protocol-specific actions) for
the protocols SFTP, SMTP, FTP. Fixing <code>multi_done()</code> for this
is a worthy task.</li>
<li><code>curl_multi_remove_handle</code> for any of the above. See
section <a href="#non-blocking-curl_multi_remove_handle">No-blocking
curl_multi_remove_handle</a></li>
<li>Calling <code>curl_ws_send()</code> from a callback</li>
</ul>
<h3 id="better-support-for-same-name-resolves">Better support for same
name resolves</h3>
<p>If a name resolve has been initiated for name NN and a second easy
handle wants to resolve that name as well, make it wait for the first
resolve to end up in the cache instead of doing a second separate
resolve. This is especially needed when adding many simultaneous handles
using the same host name when the DNS resolver can get flooded.</p>
<h3 id="non-blocking-curl_multi_remove_handle">Non-blocking
curl_multi_remove_handle()</h3>
<p>The multi interface has a few API calls that assume a blocking
behavior, like <code>add_handle()</code> and
<code>remove_handle()</code> which limits what we can do internally. The
multi API need to be moved even more into a single function that
"drives" everything in a non-blocking manner and signals when something
is done. A remove or add would then only ask for the action to get
started and then <code>multi_perform()</code> etc still be called until
the add/remove is completed.</p>
<h3 id="split-connect-and-authentication-process">Split connect and
authentication process</h3>
<p>The multi interface treats the authentication process as part of the
connect phase. As such any failures during authentication does not
trigger the relevant QUIT or LOGOFF for protocols such as IMAP, POP3 and
SMTP.</p>
<h3 id="edge-triggered-sockets-should-work">Edge-triggered sockets
should work</h3>
<p>The <code>multi_socket</code> API should work with edge-triggered
socket events. One of the internal actions that need to be improved for
this to work perfectly is the <code>maxloops</code> handling in
<code>transfer.c:readwrite_data()</code>.</p>
<h3 id="multi-upkeep">multi upkeep</h3>
<p>In libcurl 7.62.0 we introduced <code>curl_easy_upkeep</code>. It
unfortunately only works on easy handles. We should introduces a version
of that for the multi handle, and also consider doing "upkeep"
automatically on connections in the connection pool when the multi
handle is in used.</p>
<p>See <a
href="https://github.com/curl/curl/issues/3199">https://github.com/curl/curl/issues/3199</a></p>
<h3 id="virtual-external-sockets">Virtual external sockets</h3>
<p>libcurl performs operations on the given file descriptor that
presumes it is a socket and an application cannot replace them at the
moment. Allowing an application to fully replace those would allow a
larger degree of freedom and flexibility.</p>
<p>See <a
href="https://github.com/curl/curl/issues/5835">https://github.com/curl/curl/issues/5835</a></p>
<h3 id="dynamically-decide-to-use-socketpair">dynamically decide to use
socketpair</h3>
<p>For users who do not use <code>curl_multi_wait()</code> or do not
care for <code>curl_multi_wakeup()</code>, we could introduce a way to
make libcurl NOT create a socketpair in the multi handle.</p>
<p>See <a
href="https://github.com/curl/curl/issues/4829">https://github.com/curl/curl/issues/4829</a></p>
<h2 id="documentation">Documentation</h2>
<h3 id="improve-documentation-about-fork-safety">Improve documentation
about fork safety</h3>
<p>See <a
href="https://github.com/curl/curl/issues/6968">https://github.com/curl/curl/issues/6968</a></p>
<h2 id="ftp">FTP</h2>
<h3 id="host">HOST</h3>
<p>HOST is a command for a client to tell which hostname to use, to
offer FTP servers named-based virtual hosting.</p>
<p>See <a
href="https://datatracker.ietf.org/doc/html/rfc7151">https://datatracker.ietf.org/doc/html/rfc7151</a></p>
<h3 id="a-fixed-directory-listing-format">A fixed directory listing
format</h3>
<p>Since listing the contents of a remove directory with FTP is
returning the list in a format and style the server likes without any
estblished or even defactor standard existing, it would be a feature to
users if curl could parse the directory listing and output a general
curl format that is fixed and the same, independent of the server's
choice. This would allow users to better and more reliably extract
information about remote content via FTP directory listings.</p>
<h3 id="gssapi-via-windows-sspi">GSSAPI via Windows SSPI</h3>
<p>In addition to currently supporting the SASL GSSAPI mechanism
(Kerberos V5) via third-party GSS-API libraries, such as MIT Kerberos,
also add support for GSSAPI authentication via Windows SSPI.</p>
<h3 id="stat-for-list-without-data-connection">STAT for LIST without
data connection</h3>
<p>Some FTP servers allow STAT for listing directories instead of using
LIST, and the response is then sent over the control connection instead
of as the otherwise usedw data connection.</p>
<p>See <a
href="https://www.nsftools.com/tips/RawFTP.htm#STAT">https://www.nsftools.com/tips/RawFTP.htm#STAT</a></p>
<p>This is not detailed in any FTP specification.</p>
<h3 id="passive-transfer-could-try-other-ip-addresses">Passive transfer
could try other IP addresses</h3>
<p>When doing FTP operations through a proxy at localhost, the reported
spotted that curl only tried to connect once to the proxy, while it had
multiple addresses and a failed connect on one address should make it
try the next.</p>
<p>After switching to passive mode (EPSV), curl could try all IP
addresses for "localhost". Currently it tries ::1, but it should also
try 127.0.0.1.</p>
<p>See <a
href="https://github.com/curl/curl/issues/1508">https://github.com/curl/curl/issues/1508</a></p>
<h2 id="http">HTTP</h2>
<h3 id="provide-the-error-body-from-a-connect-response">Provide the
error body from a CONNECT response</h3>
<p>When curl receives a body response from a CONNECT request to a proxy,
it always just reads and ignores it. It would make some users happy if
curl instead optionally would be able to make that responsible
available. Via a new callback? Through some other means?</p>
<p>See <a
href="https://github.com/curl/curl/issues/9513">https://github.com/curl/curl/issues/9513</a></p>
<h3 id="obey-retry-after-in-redirects">Obey Retry-After in
redirects</h3>
<p>The <code>Retry-After</code> is said to dictate "the minimum time
that the user agent is asked to wait before issuing the redirected
request" and libcurl does not obey this.</p>
<p>See <a
href="https://github.com/curl/curl/issues/11447">https://github.com/curl/curl/issues/11447</a></p>
<h3 id="rearrange-request-header-order">Rearrange request header
order</h3>
<p>Server implementers often make an effort to detect browser and to
reject clients it can detect to not match. One of the last details we
cannot yet control in libcurl's HTTP requests, which also can be
exploited to detect that libcurl is in fact used even when it tries to
impersonate a browser, is the order of the request headers. I propose
that we introduce a new option in which you give headers a value, and
then when the HTTP request is built it sorts the headers based on that
number. We could then have internally created headers use a default
value so only headers that need to be moved have to be specified.</p>
<h3 id="allow-san-names-in-http2-server-push">Allow SAN names in HTTP/2
server push</h3>
<p>curl only allows HTTP/2 push promise if the provided :authority
header value exactly matches the hostname given in the URL. It could be
extended to allow any name that would match the Subject Alternative
Names in the server's TLS certificate.</p>
<p>See <a
href="https://github.com/curl/curl/pull/3581">https://github.com/curl/curl/pull/3581</a></p>
<h3 id="auth-in-urls">auth= in URLs</h3>
<p>Add the ability to specify the preferred authentication mechanism to
use by using ;auth=&lt;mech&gt; in the login part of the URL.</p>
<p>For example:</p>
<p><code>http://test:pass;auth=NTLM@example.com</code> would be
equivalent to specifying <code>--user test:pass;auth=NTLM</code> or
<code>--user test:pass --ntlm</code> from the command line.</p>
<p>Additionally this should be implemented for proxy base URLs as
well.</p>
<h3 id="alt-svc-should-fallback-if-alt-svc-does-not-work">alt-svc should
fallback if alt-svc does not work</h3>
<p>The alt-svc: header provides a set of alternative services for curl
to use instead of the original. If the first attempted one fails, it
should try the next etc and if all alternatives fail go back to the
original.</p>
<p>See <a
href="https://github.com/curl/curl/issues/4908">https://github.com/curl/curl/issues/4908</a></p>
<h3 id="require-http-version-x-or-higher">Require HTTP version X or
higher</h3>
<p>curl and libcurl provide options for trying higher HTTP versions (for
example HTTP/2) but then still allows the server to pick version 1.1. We
could consider adding a way to require a minimum version.</p>
<p>See <a
href="https://github.com/curl/curl/issues/7980">https://github.com/curl/curl/issues/7980</a></p>
<h2 id="telnet">TELNET</h2>
<h3 id="ditch-stdin">ditch stdin</h3>
<p>Reading input (to send to the remote server) on stdin is a crappy
solution for library purposes. We need to invent a good way for the
application to be able to provide the data to send.</p>
<h3 id="ditch-telnet-specific-select">ditch telnet-specific select</h3>
<p>Move the telnet support's network select() loop go away and merge the
code into the main transfer loop. Until this is done, the multi
interface does not work for telnet.</p>
<h3 id="feature-negotiation-debug-data">feature negotiation debug
data</h3>
<p>Add telnet feature negotiation data to the debug callback as header
data.</p>
<h3 id="exit-immediately-upon-connection-if-stdin-is-devnull">exit
immediately upon connection if stdin is /dev/null</h3>
<p>If it did, curl could be used to probe if there is an server there
listening on a specific port. That is, the following command would exit
immediately after the connection is established with exit code 0:</p>
<pre><code>curl -s --connect-timeout 2 telnet://example.com:80 &lt;/dev/null</code></pre>
<h2 id="smtp">SMTP</h2>
<h3 id="passing-notify-option-to-curlopt_mail_rcpt">Passing NOTIFY
option to CURLOPT_MAIL_RCPT</h3>
<p>Is there a way to pass the NOTIFY option to the
<code>CURLOPT_MAIL_RCPT</code> option ? I set a string that already
contains a bracket. For instance something like that:
<code>curl_slist_append( recipients, "&lt;foo@bar&gt; NOTIFY=SUCCESS,FAILURE" );</code></p>
<p>See <a
href="https://github.com/curl/curl/issues/8232">https://github.com/curl/curl/issues/8232</a></p>
<h3 id="enhanced-capability-support">Enhanced capability support</h3>
<p>Add the ability, for an application that uses libcurl, to obtain the
list of capabilities returned from the EHLO command.</p>
<h3 id="add-curlopt_mail_client-option">Add CURLOPT_MAIL_CLIENT
option</h3>
<p>Rather than use the URL to specify the mail client string to present
in the HELO and EHLO commands, libcurl should support a new
<code>CURLOPT</code> specifically for specifying this data as the URL is
non-standard and to be honest a bit of a hack ;-)</p>
<p>See <a
href="https://curl.se/mail/lib-2012-05/0178.html">https://curl.se/mail/lib-2012-05/0178.html</a></p>
<h2 id="pop3">POP3</h2>
<h3 id="enhanced-capability-support-1">Enhanced capability support</h3>
<p>Add the ability, for an application that uses libcurl, to obtain the
list of capabilities returned from the CAPA command.</p>
<h2 id="imap">IMAP</h2>
<h3 id="enhanced-capability-support-2">Enhanced capability support</h3>
<p>Add the ability, for an application that uses libcurl, to obtain the
list of capabilities returned from the CAPABILITY command.</p>
<h2 id="ldap">LDAP</h2>
<h3 id="sasl-based-authentication-mechanisms">SASL based authentication
mechanisms</h3>
<p>Currently the LDAP module only supports
<code>ldap_simple_bind_s()</code> in order to bind to an LDAP server.
However, this function sends username and password details using the
simple authentication mechanism (as clear text). However, it should be
possible to use <code>ldap_bind_s()</code> instead specifying the
security context information ourselves.</p>
<h3 id="curlopt_ssl_ctx_function-for-ldaps">CURLOPT_SSL_CTX_FUNCTION for
LDAPS</h3>
<p>CURLOPT_SSL_CTX_FUNCTION works perfectly for HTTPS and email
protocols, but it has no effect for LDAPS connections.</p>
<p>See <a
href="https://github.com/curl/curl/issues/4108">https://github.com/curl/curl/issues/4108</a></p>
<h3 id="paged-searches-on-ldap-server">Paged searches on LDAP
server</h3>
<p>See <a
href="https://github.com/curl/curl/issues/4452">https://github.com/curl/curl/issues/4452</a></p>
<h3 id="certificate-based-authentication">Certificate-Based
Authentication</h3>
<p>LDAPS not possible with macOS and Windows with Certificate-Based
Authentication</p>
<p>See <a
href="https://github.com/curl/curl/issues/9641">https://github.com/curl/curl/issues/9641</a></p>
<h2 id="smb">SMB</h2>
<h3 id="file-listing-support">File listing support</h3>
<p>Add support for listing the contents of an SMB share. The output
should probably be the same as/similar to FTP.</p>
<h3 id="honor-file-timestamps">Honor file timestamps</h3>
<p>The timestamp of the transferred file should reflect that of the
original file.</p>
<h3 id="use-ntlmv2">Use NTLMv2</h3>
<p>Currently the SMB authentication uses NTLMv1.</p>
<h3 id="create-remote-directories">Create remote directories</h3>
<p>Support for creating remote directories when uploading a file to a
directory that does not exist on the server, just like
<code>--ftp-create-dirs</code>.</p>
<h2 id="file">FILE</h2>
<h3 id="directory-listing-on-non-posix">Directory listing on
non-POSIX</h3>
<p>Listing the contents of a directory accessed with FILE only works on
platforms with <code>opendir</code>. Support could be added for more
systems, like Windows.</p>
<h2 id="tls">TLS</h2>
<h3 id="tls-psk-with-openssl">TLS-PSK with OpenSSL</h3>
<p>Transport Layer Security pre-shared key ciphersuites (TLS-PSK) is a
set of cryptographic protocols that provide secure communication based
on pre-shared keys (PSKs). These pre-shared keys are symmetric keys
shared in advance among the communicating parties.</p>
<p>See <a
href="https://github.com/curl/curl/issues/5081">https://github.com/curl/curl/issues/5081</a></p>
<h3 id="tls-channel-binding">TLS channel binding</h3>
<p>TLS 1.2 and 1.3 provide the ability to extract some secret data from
the TLS connection and use it in the client request (usually in some
sort of authentication) to ensure that the data sent is bound to the
specific TLS connection and cannot be successfully intercepted by a
proxy. This functionality can be used in a standard authentication
mechanism such as GSS-API or SCRAM, or in custom approaches like custom
HTTP Authentication headers.</p>
<p>For TLS 1.2, the binding type is usually tls-unique, and for TLS 1.3
it is tls-exporter. See:</p>
<ul>
<li><a
href="https://datatracker.ietf.org/doc/html/rfc5929">https://datatracker.ietf.org/doc/html/rfc5929</a></li>
<li><a
href="https://datatracker.ietf.org/doc/html/rfc9266">https://datatracker.ietf.org/doc/html/rfc9266</a></li>
<li><a
href="https://github.com/curl/curl/issues/9226">https://github.com/curl/curl/issues/9226</a></li>
</ul>
<h3 id="defeat-tls-fingerprinting">Defeat TLS fingerprinting</h3>
<p>By changing the order of TLS extensions provided in the TLS
handshake, it is sometimes possible to circumvent TLS fingerprinting by
servers. The TLS extension order is of course not the only way to
fingerprint a client.</p>
<h3 id="consider-ocsp-stapling-by-default">Consider OCSP stapling by
default</h3>
<p>Treat a negative response a reason for aborting the connection. Since
OCSP stapling is presumed to get used much less in the future when Let's
Encrypt drops the OCSP support, the benefit of this might however be
limited.</p>
<p>See <a
href="https://github.com/curl/curl/issues/15483">https://github.com/curl/curl/issues/15483</a></p>
<h3 id="provide-callback-for-cert-verification">Provide callback for
cert verification</h3>
<p>OpenSSL supports a callback for customised verification of the peer
certificate, but this does not seem to be exposed in the libcurl APIs.
Could it be? There is so much that could be done if it were.</p>
<h3 id="less-memory-massaging-with-schannel">Less memory massaging with
Schannel</h3>
<p>The Schannel backend does a lot of custom memory management we would
rather avoid: the repeated alloc + free in sends and the custom memory +
realloc system for encrypted and decrypted data. That should be avoided
and reduced for 1) efficiency and 2) safety.</p>
<h3 id="support-dane">Support DANE</h3>
<p>DNS-Based Authentication of Named Entities (DANE) is a way to provide
SSL keys and certs over DNS using DNSSEC as an alternative to the CA
model.</p>
<p>See <a
href="https://www.rfc-editor.org/rfc/rfc6698.txt">https://www.rfc-editor.org/rfc/rfc6698.txt</a></p>
<p>An <a href="https://curl.se/mail/lib-2013-03/0075.html">initial
patch</a> was posted by Suresh Krishnaswamy on March 7th 2013 but it was
a too simple approach.</p>
<p>See <a href="https://curl.se/mail/lib-2013-03/0103.html">Daniel's
comments:</a>.</p>
<p><code>libunbound</code> may be the correct library to base this
development on.</p>
<p>Bj√∂rn Stenberg wrote a separate initial take on DANE that was never
completed.</p>
<h3 id="tls-record-padding">TLS record padding</h3>
<p>TLS (1.3) offers optional record padding and OpenSSL provides an API
for it. I could make sense for libcurl to offer this ability to
applications to make traffic patterns harder to figure out by network
traffic observers.</p>
<p>See <a
href="https://github.com/curl/curl/issues/5398">https://github.com/curl/curl/issues/5398</a></p>
<h3
id="support-authority-information-access-certificate-extension-aia">Support
Authority Information Access certificate extension (AIA)</h3>
<p>AIA can provide various things like CRLs but more importantly
information about intermediate CA certificates that can allow validation
path to be fulfilled when the HTTPS server does not itself provide
them.</p>
<p>Since AIA is about downloading certs on demand to complete a TLS
handshake, it is probably a bit tricky to get done right.</p>
<p>See <a
href="https://github.com/curl/curl/issues/2793">https://github.com/curl/curl/issues/2793</a></p>
<h3 id="some-tls-options-are-not-offered-for-https-proxies">Some TLS
options are not offered for HTTPS proxies</h3>
<p>Some TLS related options to the command line tool and libcurl are
only provided for the server and not for HTTPS proxies.
<code>--proxy-tls-max</code>, <code>--proxy-tlsv1.3</code>,
<code>--proxy-curves</code> and a few more. See:</p>
<ul>
<li><a
href="https://curl.se/libcurl/c/tls-options.html">https://curl.se/libcurl/c/tls-options.html</a></li>
<li><a
href="https://github.com/curl/curl/issues/12286">https://github.com/curl/curl/issues/12286</a></li>
</ul>
<h3 id="make-sure-we-forbid-tls-13-post-handshake-authentication">Make
sure we forbid TLS 1.3 post-handshake authentication</h3>
<p>RFC 8740 explains how using HTTP/2 must forbid the use of TLS 1.3
post-handshake authentication. We should make sure to live up to
that.</p>
<p>See <a
href="https://github.com/curl/curl/issues/5396">https://github.com/curl/curl/issues/5396</a></p>
<h3 id="support-the-clienthello-extension">Support the clienthello
extension</h3>
<p>Certain stupid networks and middle boxes have a problem with SSL
handshake packets that are within a certain size range because how that
sets some bits that previously (in older TLS version) were not set. The
clienthello extension adds padding to avoid that size range. See:</p>
<ul>
<li><a
href="https://datatracker.ietf.org/doc/html/rfc7685">https://datatracker.ietf.org/doc/html/rfc7685</a></li>
<li><a
href="https://github.com/curl/curl/issues/2299">https://github.com/curl/curl/issues/2299</a></li>
</ul>
<h3 id="share-the-ca-cache">Share the CA cache</h3>
<p>For TLS backends that supports CA caching, it makes sense to allow
the share object to be used to store the CA cache as well via the share
API. Would allow multiple easy handles to reuse the CA cache and save
themselves from a lot of extra processing overhead.</p>
<h3 id="add-missing-features-to-tls-backends">Add missing features to
TLS backends</h3>
<p>The feature matrix at <a
href="https://curl.se/libcurl/c/tls-options.html">curl.se/tls-options</a>
shows which features are supported by which TLS backends, and thus also
where there are feature gaps.</p>
<h2 id="proxy">Proxy</h2>
<h3 id="retry-socks-handshake-on-address-type-not-supported">Retry SOCKS
handshake on address type not supported</h3>
<p>When curl resolves a hostname, it might get a mix of IPv6 and IPv4
returned. curl might then use an IPv6 address with a SOCKS5 proxy, which
- if it does not support IPv6 - returns "Address type not supported" and
curl exits with that error.</p>
<p>Perhaps it is preferred if curl would in this situation instead first
retry the SOCKS handshake again for this case and then use one of the
IPv4 addresses for the target host.</p>
<p>See <a
href="https://github.com/curl/curl/issues/17222">https://github.com/curl/curl/issues/17222</a></p>
<h2 id="schannel">Schannel</h2>
<h3 id="extend-support-for-client-certificate-authentication">Extend
support for client certificate authentication</h3>
<p>The existing support for the <code>-E/--cert</code> and
<code>--key</code> options could be extended by supplying a custom
certificate and key in PEM format.</p>
<p>See <a
href="https://learn.microsoft.com/en-us/windows/win32/secauthn/getting-a-certificate-for-schannel">https://learn.microsoft.com/en-us/windows/win32/secauthn/getting-a-certificate-for-schannel</a></p>
<h3 id="extend-support-for-the---ciphers-option">Extend support for the
--ciphers option</h3>
<p>The existing support for the <code>--ciphers</code> option could be
extended by mapping the OpenSSL/GnuTLS cipher suites to the Schannel
APIs.</p>
<p>See <a
href="https://learn.microsoft.com/en-us/windows/win32/secauthn/specifying-schannel-ciphers-and-cipher-strengths">https://learn.microsoft.com/en-us/windows/win32/secauthn/specifying-schannel-ciphers-and-cipher-strengths</a></p>
<h3 id="add-option-to-allow-abrupt-server-closure">Add option to allow
abrupt server closure</h3>
<p>libcurl with Schannel errors without a known termination point from
the server (such as length of transfer, or SSL "close notify" alert) to
prevent against a truncation attack. Really old servers may neglect to
send any termination point. An option could be added to ignore such
abrupt closures.</p>
<p>See <a
href="https://github.com/curl/curl/issues/4427">https://github.com/curl/curl/issues/4427</a></p>
<h2 id="sasl">SASL</h2>
<h3 id="other-authentication-mechanisms">Other authentication
mechanisms</h3>
<p>Add support for other authentication mechanisms such as OLP,
GSS-SPNEGO and others.</p>
<h3 id="add-qop-support-to-gssapi-authentication">Add QOP support to
GSSAPI authentication</h3>
<p>Currently the GSSAPI authentication only supports the default QOP of
auth (Authentication), whilst Kerberos V5 supports both auth-int
(Authentication with integrity protection) and auth-conf (Authentication
with integrity and privacy protection).</p>
<h2 id="ssh-protocols">SSH protocols</h2>
<h3 id="multiplexing">Multiplexing</h3>
<p>SSH is a perfectly fine multiplexed protocols which would allow
libcurl to do multiple parallel transfers from the same host using the
same connection, much in the same spirit as HTTP/2 does. libcurl however
does not take advantage of that ability but does instead always create a
new connection for new transfers even if an existing connection already
exists to the host.</p>
<p>To fix this, libcurl would have to detect an existing connection and
"attach" the new transfer to the existing one.</p>
<h3 id="handle-growing-sftp-files">Handle growing SFTP files</h3>
<p>The SFTP code in libcurl checks the file size <em>before</em> a
transfer starts and then proceeds to transfer exactly that amount of
data. If the remote file grows while the transfer is in progress libcurl
does not notice and does not adapt. The OpenSSH SFTP command line tool
does and libcurl could also just attempt to download more to see if
there is more to get...</p>
<p>See <a
href="https://github.com/curl/curl/issues/4344">https://github.com/curl/curl/issues/4344</a></p>
<h3 id="read-keys-from-sshid_ecdsa-id_ed25519">Read keys from
~/.ssh/id_ecdsa, id_ed25519</h3>
<p>The libssh2 backend in curl is limited to only reading keys from
<code>id_rsa</code> and <code>id_dsa</code>, which makes it fail
connecting to servers that use more modern key types.</p>
<p>See <a
href="https://github.com/curl/curl/issues/8586">https://github.com/curl/curl/issues/8586</a></p>
<h3 id="support-curlopt_prequote">Support CURLOPT_PREQUOTE</h3>
<p>The two other QUOTE options are supported for SFTP, but this was left
out for unknown reasons.</p>
<h3 id="ssh-over-https-proxy-with-more-backends">SSH over HTTPS proxy
with more backends</h3>
<p>The SSH based protocols SFTP and SCP did not work over HTTPS proxy at
all until PR <a
href="https://github.com/curl/curl/pull/6021">https://github.com/curl/curl/pull/6021</a>
brought the functionality with the libssh2 backend. Presumably, this
support can/could be added for the other backends as well.</p>
<h3 id="sftp-with-scp">SFTP with SCP://</h3>
<p>OpenSSH 9 switched their 'scp' tool to speak SFTP under the hood.
Going forward it might be worth having curl or libcurl attempt SFTP if
SCP fails to follow suite.</p>
<h2 id="command-line-tool">Command line tool</h2>
<h3 id="sync">sync</h3>
<pre><code>curl --sync http://example.com/feed[1-100].rss
#or 
curl --sync http://example.net/{index,calendar,history}.html</code></pre>
<p>Downloads a range or set of URLs using the remote name, but only if
the remote file is newer than the local file. A
<code>Last-Modified</code> HTTP date header should also be used to set
the mod date on the downloaded file.</p>
<h3 id="glob-posts">glob posts</h3>
<p>Globbing support for <code>-d</code> and <code>-F</code>, as in
<code>curl -d "name=foo[0-9]" URL</code>. This is easily scripted
though.</p>
<h3 id="--proxycommand">--proxycommand</h3>
<p>Allow the user to make curl run a command and use its stdio to make
requests and not do any network connection by itself. Example:</p>
<pre><code>curl --proxycommand &#39;ssh pi@raspberrypi.local -W 10.1.1.75 80&#39;      http://some/otherwise/unavailable/service.php</code></pre>
<p>See <a
href="https://github.com/curl/curl/issues/4941">https://github.com/curl/curl/issues/4941</a></p>
<h3 id="utf-8-filenames-in-content-disposition">UTF-8 filenames in
Content-Disposition</h3>
<p>RFC 6266 documents how UTF-8 names can be passed to a client in the
Content-Disposition header, and curl does not support this.</p>
<p>See <a
href="https://github.com/curl/curl/issues/1888">https://github.com/curl/curl/issues/1888</a></p>
<h3 id="option-to-make--z-merge-lined-based-outputs-on-stdout">Option to
make -Z merge lined based outputs on stdout</h3>
<p>When a user requests multiple lined based files using <code>-Z</code>
and sends them to stdout, curl does not "merge" and send complete lines
fine but may send partial lines from several sources.</p>
<p>See <a
href="https://github.com/curl/curl/issues/5175">https://github.com/curl/curl/issues/5175</a></p>
<h3
id="specify-which-response-codes-that-make--f--fail-return-error">specify
which response codes that make -f/--fail return error</h3>
<p>Allows a user to better specify exactly which error code(s) that are
fine and which are errors for their specific uses cases</p>
<h3 id="choose-the-name-of-file-in-braces-for-complex-urls">Choose the
name of file in braces for complex URLs</h3>
<p>When using braces to download a list of URLs and you use complicated
names in the list of alternatives, it could be handy to allow curl to
use other names when saving.</p>
<p>Consider a way to offer that. Possibly like
{partURL1:name1,partURL2:name2,partURL3:name3} where the name following
the colon is the output name.</p>
<p>See <a
href="https://github.com/curl/curl/issues/221">https://github.com/curl/curl/issues/221</a></p>
<h3 id="improve-how-curl-works-in-a-windows-console-window">improve how
curl works in a Windows console window</h3>
<p>If you pull the scrollbar when transferring with curl in a Windows
console window, the transfer is interrupted and can get disconnected.
This can probably be improved.</p>
<p>See <a
href="https://github.com/curl/curl/issues/322">https://github.com/curl/curl/issues/322</a></p>
<h3 id="windows-set-attribute-archive-for-completed-downloads">Windows:
set attribute 'archive' for completed downloads</h3>
<p>The archive bit (FILE_ATTRIBUTE_ARCHIVE, 0x20) separates files that
shall be backed up from those that are either not ready or have not
changed.</p>
<p>Downloads in progress are neither ready to be backed up, nor should
they be opened by a different process. Only after a download has been
completed it is sensible to include it in any integer snapshot or backup
of the system.</p>
<p>See <a
href="https://github.com/curl/curl/issues/3354">https://github.com/curl/curl/issues/3354</a></p>
<h3 id="keep-running-read-instructions-from-pipesocket">keep running,
read instructions from pipe/socket</h3>
<p>Provide an option that makes curl not exit after the last URL (or
even work without a given URL), and then make it read instructions
passed on a pipe or over a socket to make further instructions so that a
second subsequent curl invoke can talk to the still running instance and
ask for transfers to get done, and thus maintain its connection pool,
DNS cache and more.</p>
<h3 id="acknowledge-ratelimit-headers">Acknowledge Ratelimit
headers</h3>
<p>Consider a command line option that can make curl do multiple serial
requests while acknowledging server specified rate limits. See:</p>
<ul>
<li><a
href="https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/">https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/</a></li>
<li><a
href="https://github.com/curl/curl/issues/5406">https://github.com/curl/curl/issues/5406</a></li>
</ul>
<h3 id="--dry-run">--dry-run</h3>
<p>A command line option that makes curl show exactly what it would do
and send if it would run for real.</p>
<p>See <a
href="https://github.com/curl/curl/issues/5426">https://github.com/curl/curl/issues/5426</a></p>
<h3 id="--retry-should-resume">--retry should resume</h3>
<p>When <code>--retry</code> is used and curl actually retries transfer,
it should use the already transferred data and do a resumed transfer for
the rest (when possible) so that it does not have to transfer the same
data again that was already transferred before the retry.</p>
<p>See <a
href="https://github.com/curl/curl/issues/1084">https://github.com/curl/curl/issues/1084</a></p>
<h3 id="consider-filename-from-the-redirected-url-with--o-">consider
filename from the redirected URL with -O ?</h3>
<p>When a user gives a URL and uses <code>-O</code>, and curl follows a
redirect to a new URL, the filename is not extracted and used from the
newly redirected-to URL even if the new URL may have a much more
sensible filename.</p>
<p>This is clearly documented and helps for security since there is no
surprise to users which filename that might get overwritten, but maybe a
new option could allow for this or maybe <code>-J</code> should imply
such a treatment as well as <code>-J</code> already allows for the
server to decide what filename to use so it already provides the "may
overwrite any file" risk.</p>
<p>This is extra tricky if the original URL has no filename part at all
since then the current code path does error out with an error message,
and we cannot <em>know</em> already at that point if curl is redirected
to a URL that has a filename...</p>
<p>See <a
href="https://github.com/curl/curl/issues/1241">https://github.com/curl/curl/issues/1241</a></p>
<h3 id="retry-on-network-is-unreachable">retry on network is
unreachable</h3>
<p>The <code>--retry</code> option retries transfers on "transient
failures". We later added <code>--retry-connrefused</code> to also retry
for "connection refused" errors.</p>
<p>Suggestions have been brought to also allow retry on "network is
unreachable" errors and while totally reasonable, maybe we should
consider a way to make this more configurable than to add a new option
for every new error people want to retry for?</p>
<p>See <a
href="https://github.com/curl/curl/issues/1603">https://github.com/curl/curl/issues/1603</a></p>
<h3 id="hostname-sections-in-config-files">hostname sections in config
files</h3>
<p>config files would be more powerful if they could set different
configurations depending on used URLs, hostname or possibly origin. Then
a default <code>.curlrc</code> could a specific user-agent only when
doing requests against a certain site.</p>
<h3 id="retry-on-the-redirected-to-url">retry on the redirected-to
URL</h3>
<p>When curl is told to <code>--retry</code> a failed transfer and
follows redirects, it might get an HTTP 429 response from the
redirected-to URL and not the original one, which then could make curl
decide to rather retry the transfer on that URL only instead of the
original operation to the original URL.</p>
<p>Perhaps extra emphasized if the original transfer is a large POST
that redirects to a separate GET, and that GET is what gets the 529</p>
<p>See <a
href="https://github.com/curl/curl/issues/5462">https://github.com/curl/curl/issues/5462</a></p>
<h3 id="set-the-modification-date-on-an-uploaded-file">Set the
modification date on an uploaded file</h3>
<p>For SFTP and possibly FTP, curl could offer an option to set the
modification time for the uploaded file.</p>
<p>See <a
href="https://github.com/curl/curl/issues/5768">https://github.com/curl/curl/issues/5768</a></p>
<h3 id="use-multiple-parallel-transfers-for-a-single-download">Use
multiple parallel transfers for a single download</h3>
<p>To enhance transfer speed, downloading a single URL can be split up
into multiple separate range downloads that get combined into a single
final result.</p>
<p>An ideal implementation would not use a specified number of parallel
transfers, but curl could:</p>
<ul>
<li>First start getting the full file as transfer A</li>
<li>If after N seconds have passed and the transfer is expected to
continue for M seconds or more, add a new transfer (B) that asks for the
second half of A's content (and stop A at the middle).</li>
<li>If splitting up the work improves the transfer rate, it could then
be done again. Then again, etc up to a limit.</li>
</ul>
<p>This way, if transfer B fails (because <code>Range:</code> is not
supported) it lets transfer A remain the single one. N and M could be
set to some sensible defaults.</p>
<p>See <a
href="https://github.com/curl/curl/issues/5774">https://github.com/curl/curl/issues/5774</a></p>
<h3 id="prevent-terminal-injection-when-writing-to-terminal">Prevent
terminal injection when writing to terminal</h3>
<p>curl could offer an option to make escape sequence either
non-functional or avoid cursor moves or similar to reduce the risk of a
user getting tricked by clever tricks.</p>
<p>See <a
href="https://github.com/curl/curl/issues/6150">https://github.com/curl/curl/issues/6150</a></p>
<h3 id="custom-progress-meter-update-interval">Custom progress meter
update interval</h3>
<p>Users who are for example doing large downloads in CI or remote
setups might want the occasional progress meter update to see that the
transfer is progressing and has not stuck, but they may not appreciate
the many-times-a-second frequency curl can end up doing it with now.</p>
<h3 id="-j-and--o-with--encoded-filenames">-J and -O with %-encoded
filenames</h3>
<p><code>-J/--remote-header-name</code> does not decode %-encoded
filenames. RFC 6266 details how it should be done. The can of worm is
basically that we have no charset handling in curl and ASCII &gt;=128 is
a challenge for us. Not to mention that decoding also means that we need
to check for nastiness that is attempted, like "../" sequences and the
like. Probably everything to the left of any embedded slashes should be
cut off.</p>
<p>See <a
href="https://curl.se/bug/view.cgi?id=1294">https://curl.se/bug/view.cgi?id=1294</a></p>
<p><code>-O</code> also does not decode %-encoded names, and while it
has even less information about the charset involved the process is
similar to the <code>-J</code> case.</p>
<p>Note that we do not decode <code>-O</code> without the user asking
for it with some other means, since <code>-O</code> has always been
documented to use the name exactly as specified in the URL.</p>
<h3 id="-j-with--c--">-J with -C -</h3>
<p>When using <code>-J</code> (with <code>-O</code>), automatically
resumed downloading together with <code>-C -</code> fails. Without
<code>-J</code> the same command line works. This happens because the
resume logic is worked out before the target filename (and thus its
pre-transfer size) has been figured out. This can be improved.</p>
<p>See <a
href="https://curl.se/bug/view.cgi?id=1169">https://curl.se/bug/view.cgi?id=1169</a></p>
<h3 id="--retry-and-transfer-timeouts">--retry and transfer
timeouts</h3>
<p>If using <code>--retry</code> and the transfer timeouts (possibly due
to using <code>-m</code> or <code>-y/-Y</code>) the next attempt does
not resume the transfer properly from what was downloaded in the
previous attempt but truncates and restarts at the original position
where it was at before the previous failed attempt.</p>
<p>See <a
href="https://curl.se/mail/lib-2008-01/0080.html">https://curl.se/mail/lib-2008-01/0080.html</a></p>
<h2 id="build">Build</h2>
<h3 id="enable-pie-and-relro-by-default">Enable PIE and RELRO by
default</h3>
<p>Especially when having programs that execute curl via the command
line, <code>PIE</code> renders the exploitation of memory corruption
vulnerabilities a lot more difficult. This can be attributed to the
additional information leaks being required to conduct a successful
attack. <code>RELRO</code>, on the other hand, masks different binary
sections like the <code>GOT</code> as read-only and thus kills a handful
of techniques that come in handy when attackers are able to arbitrarily
overwrite memory. A few tests showed that enabling these features had
close to no impact, neither on the performance nor on the general
functionality of curl.</p>
<h3 id="do-not-use-gnu-libtool-on-openbsd">Do not use GNU libtool on
OpenBSD</h3>
<p>When compiling curl on OpenBSD with <code>--enable-debug</code> it
gives linking errors when you use GNU <code>libtool</code>. This can be
fixed by using the <code>libtool</code> provided by OpenBSD itself.
However for this the user always needs to invoke make with
<code>LIBTOOL=/usr/bin/libtool</code>. It would be nice if the script
could have some magic to detect if this system is an OpenBSD host and
then use the OpenBSD <code>libtool</code> instead.</p>
<p>See <a
href="https://github.com/curl/curl/issues/5862">https://github.com/curl/curl/issues/5862</a></p>
<h3 id="package-curl-for-windows-in-a-signed-installer">Package curl for
Windows in a signed installer</h3>
<p>See <a
href="https://github.com/curl/curl/issues/5424">https://github.com/curl/curl/issues/5424</a></p>
<h3 id="make-configure-use---cache-file-more-and-better">make configure
use --cache-file more and better</h3>
<p>The configure script can be improved to cache more values so that
repeated invokes run much faster.</p>
<p>See <a
href="https://github.com/curl/curl/issues/7753">https://github.com/curl/curl/issues/7753</a></p>
<h2 id="test-suite">Test suite</h2>
<h3 id="ssl-tunnel">SSL tunnel</h3>
<p>Make our own version of <code>stunnel</code> for simple port
forwarding to enable HTTPS and FTP-SSL tests without the
<code>stunnel</code> dependency, and it could allow us to provide test
tools built with either OpenSSL or GnuTLS</p>
<h3 id="more-protocols-supported">more protocols supported</h3>
<p>Extend the test suite to include more protocols. The telnet could
just do FTP or http operations (for which we have test servers).</p>
<h3 id="more-platforms-supported">more platforms supported</h3>
<p>Make the test suite work on more platforms. OpenBSD and macOS. Remove
fork()s and it should become even more portable.</p>
<h3 id="write-an-smb-test-server-to-replace-impacket">write an SMB test
server to replace impacket</h3>
<p>This would allow us to run SMB tests on more platforms and do better
and more covering tests.</p>
<p>See <a
href="https://github.com/curl/curl/issues/15697">https://github.com/curl/curl/issues/15697</a></p>
<h3 id="use-the-rfc-6265-test-suite">Use the RFC 6265 test suite</h3>
<p>A test suite made for HTTP cookies (RFC 6265) by Adam Barth is
available at <a
href="https://github.com/abarth/http-state/tree/master/tests">http-state/tests</a>.</p>
<p>It would be good if someone would write a script/setup that would run
curl with that test suite and detect deviances. Ideally, that would even
be incorporated into our regular test suite.</p>
<h3 id="run-web-platform-tests-url-tests">Run web-platform-tests URL
tests</h3>
<p>Run web-platform-tests URL tests and compare results with browsers on
wpt.fyi</p>
<p>It would help us find issues to fix and help us document where our
parser differs from the WHATWG URL spec parsers.</p>
<p>See <a
href="https://github.com/curl/curl/issues/4477">https://github.com/curl/curl/issues/4477</a></p>
<h2 id="mqtt">MQTT</h2>
<h3 id="support-rate-limiting">Support rate-limiting</h3>
<p>The rate-limiting logic is done in the PERFORMING state in multi.c
but MQTT is not (yet) implemented to use that.</p>
<h3 id="support-mqtts">Support MQTTS</h3>
<h3 id="handle-network-blocks">Handle network blocks</h3>
<p>Running test suite with
<code>CURL_DBG_SOCK_WBLOCK=90 ./runtests.pl -a mqtt</code> makes several
MQTT test cases fail where they should not.</p>
<h3 id="large-payloads">large payloads</h3>
<p>libcurl unnecessarily allocates heap memory to hold the entire
payload to get sent, when the data is already perfectly accessible where
it is when <code>CURLOPT_POSTFIELDS</code> is used. This is highly
inefficient for larger payloads. Additionally, libcurl does not support
using the read callback for sending MQTT which is yet another way to
avoid having to hold large payload in memory.</p>
<h2 id="tftp">TFTP</h2>
<h3 id="tftp-does-not-convert-lf-to-crlf-for-modenetascii">TFTP does not
convert LF to CRLF for mode=netascii</h3>
<p>RFC 3617 defines that an TFTP transfer can be done using "netascii"
mode. curl does not support extracting that mode from the URL nor does
it treat such transfers specifically. It should probably do LF to CRLF
translations for them.</p>
<p>See <a
href="https://github.com/curl/curl/issues/12655">https://github.com/curl/curl/issues/12655</a></p>
<h2 id="gopher">Gopher</h2>
<h3 id="handle-network-blocks-1">Handle network blocks</h3>
<p>Running test suite with
<code>CURL_DBG_SOCK_WBLOCK=90 ./runtests.pl -a 1200 to 1300</code> makes
several Gopher test cases fail where they should not.</p>
</div>
</div>
</body>
</html>
