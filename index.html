<!doctype html>
<html>
<head>
 <meta charset="utf-8">
 <title>Markdown to HTML</title>
 <link rel="icon" href="/favicon.png">
 <link rel="stylesheet" 
 href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.8.1/github-markdown.min.css"
 crossorigin="anonymous" referrerpolicy="no-referrer" />
 <style>
  .markdown-body {
   box-sizing: border-box;
   min-width: 200px;
   max-width: 980px;
   margin: 0 auto;
   padding: 45px;
  }
  @media (max-width: 767px) {
   .markdown-body { padding: 15px; }
  }
 </style>
</head>

<body>
 <article class="markdown-body" id="parseMarkdown"></article>

 <script>
  // Markdown to HTML Converter with Custom Style Comments
  (function() {
   const STYLE_COMMENT_REGEX = /<!--\s*style\s*=\s*"([^"]+)"\s*-->/gi;
   const INLINE_STYLE_REGEX = /<!--\s*style\s*=\s*"([^"]+)"\s*-->/i;

   // Extract style from comment
   function extractStyle(comment) {
    const match = comment.match(/style\s*=\s*"([^"]+)"/i);
    return match ? match[1] : '';
   }

   // Apply style to HTML tag
   function applyStyleToTag(html, style) {
    if (!style) return html;
    return html.replace(/^<(\w+)/, (match, tag) => {
     return `<${tag} style="${style}"`;
    });
   }

   // Process inline style comments within a line
   function processInlineStyles(line) {
    let processed = line;
    let styleToApply = '';
    
    // Check for trailing style comment
    const trailingMatch = processed.match(/<!--\s*style\s*=\s*"([^"]+)"\s*-->$/);
    if (trailingMatch) {
     styleToApply = trailingMatch[1];
     processed = processed.replace(/<!--\s*style\s*=\s*"([^"]+)"\s*-->$/, '').trim();
    }
    
    return { line: processed, style: styleToApply };
   }

   // Convert markdown line to HTML
   function convertLine(line, pendingParentStyle) {
    let html = '';
    let { line: cleanLine, style: inlineStyle } = processInlineStyles(line);
    
    // Headings
    const headingMatch = cleanLine.match(/^(#{1,6})\s+(.+)$/);
    if (headingMatch) {
     const level = headingMatch[1].length;
     const text = convertInlineMarkdown(headingMatch[2]);
     html = `<h${level}>${text}</h${level}>`;
     if (inlineStyle) html = applyStyleToTag(html, inlineStyle);
     return { html, type: 'heading' };
    }

    // Horizontal rules
    if (/^(-{3,}|\*{3,}|_{3,})$/.test(cleanLine)) {
     html = '<hr>';
     if (inlineStyle) html = applyStyleToTag(html, inlineStyle);
     return { html, type: 'hr' };
    }

    // Blockquotes
    if (cleanLine.startsWith('> ')) {
     const content = convertInlineMarkdown(cleanLine.slice(2));
     html = `<blockquote><p>${content}</p></blockquote>`;
     if (inlineStyle) html = applyStyleToTag(html, inlineStyle);
     return { html, type: 'blockquote' };
    }

    // Unordered list items
    const ulMatch = cleanLine.match(/^(\s*)[-*+]\s+(.+)$/);
    if (ulMatch) {
     const indent = ulMatch[1].length;
     const content = convertInlineMarkdown(ulMatch[2]);
     html = `<li>${content}</li>`;
     if (inlineStyle) html = applyStyleToTag(html, inlineStyle);
     return { html, type: 'ul', indent, parentStyle: pendingParentStyle };
    }

    // Ordered list items
    const olMatch = cleanLine.match(/^(\s*)\d+\.\s+(.+)$/);
    if (olMatch) {
     const indent = olMatch[1].length;
     const content = convertInlineMarkdown(olMatch[2]);
     html = `<li>${content}</li>`;
     if (inlineStyle) html = applyStyleToTag(html, inlineStyle);
     return { html, type: 'ol', indent, parentStyle: pendingParentStyle };
    }

    // Task list items
    const taskMatch = cleanLine.match(/^(\s*)[-*+]\s+\[([ xX])\]\s*(.*)$/);
    if (taskMatch) {
     const checked = taskMatch[2].toLowerCase() === 'x' ? ' checked' : '';
     const content = convertInlineMarkdown(taskMatch[3]);
     html = `<li><input type="checkbox"${checked} disabled> ${content}</li>`;
     if (inlineStyle) html = applyStyleToTag(html, inlineStyle);
     return { html, type: 'ul', indent: taskMatch[1].length, parentStyle: pendingParentStyle };
    }

    // Images
    const imgMatch = cleanLine.match(/^!\[([^\]]*)\]\(([^)\s]+)(?:\s+"([^"]+)")?\)$/);
    if (imgMatch) {
     const alt = imgMatch[1];
     const src = imgMatch[2];
     const title = imgMatch[3] ? ` title="${imgMatch[3]}"` : '';
     html = `<img src="${src}" alt="${alt}"${title}>`;
     if (inlineStyle) html = applyStyleToTag(html, inlineStyle);
     return { html: `<p>${html}</p>`, type: 'image' };
    }

    // Paragraph (default)
    if (cleanLine.trim()) {
     html = `<p>${convertInlineMarkdown(cleanLine)}</p>`;
     if (inlineStyle) html = applyStyleToTag(html, inlineStyle);
     return { html, type: 'paragraph' };
    }

    return { html: '', type: 'empty' };
   }

   // Convert inline markdown elements
   function convertInlineMarkdown(text) {
    // Images
    text = text.replace(/!\[([^\]]*)\]\(([^)\s]+)(?:\s+"([^"]+)")?\)/g, (match, alt, src, title) => {
     const titleAttr = title ? ` title="${title}"` : '';
     return `<img src="${src}" alt="${alt}"${titleAttr}>`;
    });

    // Links
    text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');

    // Bold and italic
    text = text.replace(/\*\*\*([^*]+)\*\*\*/g, '<strong><em>$1</em></strong>');
    text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    text = text.replace(/__([^_]+)__/g, '<strong>$1</strong>');
    text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');
    text = text.replace(/_([^_]+)_/g, '<em>$1</em>');

    // Strikethrough
    text = text.replace(/~~([^~]+)~~/g, '<del>$1</del>');

    // Inline code
    text = text.replace(/`([^`]+)`/g, '<code>$1</code>');

    // Footnotes
    text = text.replace(/\[\^(\d+)\]/g, '<sup><a href="#fn$1" id="fnref$1">$1</a></sup>');

    return text;
   }

   // Process code blocks
   function processCodeBlocks(lines) {
    const result = [];
    let inCodeBlock = false;
    let codeContent = [];
    let codeLang = '';
    let codeStyle = '';

    for (let i = 0; i < lines.length; i++) {
     const line = lines[i];
     
     if (line.match(/^```(\w*)/) && !inCodeBlock) {
      inCodeBlock = true;
      codeLang = line.match(/^```(\w*)/)[1] || '';
      codeContent = [];
      // Check for style comment above
      if (i > 0 && INLINE_STYLE_REGEX.test(lines[i - 1])) {
       codeStyle = extractStyle(lines[i - 1]);
       result.pop(); // Remove the style comment line
      }
     } else if (line === '```' && inCodeBlock) {
      inCodeBlock = false;
      const langClass = codeLang ? ` class="language-${codeLang}"` : '';
      let pre = `<pre><code${langClass}>${escapeHtml(codeContent.join('\n'))}</code></pre>`;
      if (codeStyle) {
       pre = applyStyleToTag(pre, codeStyle);
       codeStyle = '';
      }
      result.push({ type: 'codeblock', html: pre });
     } else if (inCodeBlock) {
      codeContent.push(line);
     } else {
      result.push({ type: 'line', content: line });
     }
    }

    return result;
   }

   // Process tables
   function processTable(lines, startIdx) {
    const rows = [];
    let i = startIdx;
    
    while (i < lines.length && lines[i].content && lines[i].content.includes('|')) {
     rows.push(lines[i].content);
     i++;
    }

    if (rows.length < 2) return { html: '', endIdx: startIdx };

    // Check for separator row
    if (!rows[1].match(/^\|?\s*[-:]+/)) return { html: '', endIdx: startIdx };

    let html = '<table>';
    
    // Header row
    const headers = rows[0].split('|').filter(c => c.trim());
    html += '<thead><tr>';
    headers.forEach(h => html += `<th>${convertInlineMarkdown(h.trim())}</th>`);
    html += '</tr></thead>';

    // Body rows
    html += '<tbody>';
    for (let j = 2; j < rows.length; j++) {
     const cells = rows[j].split('|').filter(c => c.trim());
     html += '<tr>';
     cells.forEach(c => html += `<td>${convertInlineMarkdown(c.trim())}</td>`);
     html += '</tr>';
    }
    html += '</tbody></table>';

    return { html, endIdx: i };
   }

   // Escape HTML entities
   function escapeHtml(text) {
    const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
    return text.replace(/[&<>"']/g, m => map[m]);
   }

   // Main conversion function
   function convertMarkdownToHtml(markdown) {
    const lines = markdown.split('\n');
    const processed = processCodeBlocks(lines);
    let html = '';
    let currentList = null;
    let listStack = [];
    let pendingParentStyle = '';
    let footnotes = {};

    for (let i = 0; i < processed.length; i++) {
     const item = processed[i];

     if (item.type === 'codeblock') {
      // Close any open lists
      while (listStack.length) {
       html += `</${listStack.pop()}>`;
      }
      currentList = null;
      html += item.html;
      continue;
     }

     const line = item.content;

     // Check for style-only comment (for parent styling)
     if (line && INLINE_STYLE_REGEX.test(line) && line.trim().match(/^<!--\s*style\s*=\s*"[^"]+"\s*-->$/)) {
      pendingParentStyle = extractStyle(line);
      continue;
     }

     // Check for footnote definitions
     const footnoteMatch = line && line.match(/^\[\^(\d+)\]:\s*(.+)$/);
     if (footnoteMatch) {
      footnotes[footnoteMatch[1]] = footnoteMatch[2];
      continue;
     }

     // Skip empty lines but close lists
     if (!line || !line.trim()) {
      while (listStack.length) {
       html += `</${listStack.pop()}>`;
      }
      currentList = null;
      continue;
     }

     // Check for table
     if (line.includes('|') && i + 1 < processed.length && 
         processed[i + 1].content && processed[i + 1].content.match(/^\|?\s*[-:|]+/)) {
      while (listStack.length) {
       html += `</${listStack.pop()}>`;
      }
      currentList = null;
      const tableResult = processTable(processed, i);
      html += tableResult.html;
      i = tableResult.endIdx - 1;
      continue;
     }

     const result = convertLine(line, pendingParentStyle);

     // Handle lists
     if (result.type === 'ul' || result.type === 'ol') {
      const listTag = result.type;
      
      if (currentList !== listTag || listStack.length === 0) {
       if (listStack.length && currentList !== listTag) {
        html += `</${listStack.pop()}>`;
       }
       let openTag = `<${listTag}>`;
       if (pendingParentStyle) {
        openTag = `<${listTag} style="${pendingParentStyle}">`;
        pendingParentStyle = '';
       }
       html += openTag;
       listStack.push(listTag);
       currentList = listTag;
      }
      html += result.html;
     } else {
      // Close any open lists
      while (listStack.length) {
       html += `</${listStack.pop()}>`;
      }
      currentList = null;
      pendingParentStyle = '';
      html += result.html;
     }
    }

    // Close any remaining open lists
    while (listStack.length) {
     html += `</${listStack.pop()}>`;
    }

    // Add footnotes section if any
    if (Object.keys(footnotes).length) {
     html += '<hr><section class="footnotes"><ol>';
     for (const [id, text] of Object.entries(footnotes)) {
      html += `<li id="fn${id}">${convertInlineMarkdown(text)} <a href="#fnref${id}">â†©</a></li>`;
     }
     html += '</ol></section>';
    }

    // Process math blocks
    html = html.replace(/\$\$([^$]+)\$\$/g, '<div class="math">$$1$</div>');
    html = html.replace(/\$([^$\n]+)\$/g, '<span class="math">$$$1$$</span>');

    return html;
   }

   // Fetch and convert markdown file
   function fetchAndConvert(url) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function() {
     if (xhr.readyState === 4) {
      if (xhr.status === 200 || xhr.status === 0) {
       const markdown = xhr.responseText;
       const html = convertMarkdownToHtml(markdown);
       document.getElementById('parseMarkdown').innerHTML = html;
      } else {
       document.getElementById('parseMarkdown').innerHTML = 
        '<p>Error loading markdown file.</p>';
      }
     }
    };
    xhr.send();
   }

   // Initialize
   document.addEventListener('DOMContentLoaded', function() {
    fetchAndConvert('file.md');
   });
  })();
 </script>
</body>
</html>
